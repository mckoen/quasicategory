import Quasicategory.Basic

universe w v v' u u'

namespace SSet

open CategoryTheory Simplicial MorphismProperty

open MonoidalCategory in
instance tensorLeft_PreservesMonomorphisms (B : SSet) :
    Functor.PreservesMonomorphisms (tensorLeft B) where
  preserves _ hf := by
    rw [NatTrans.mono_iff_mono_app] at hf ⊢
    intro k
    replace hf := hf k
    rw [mono_iff_injective] at hf ⊢
    rintro ⟨b, x⟩ ⟨b', x'⟩ h
    rw [Prod.ext_iff] at h
    exact Prod.ext h.1 (hf h.2)

instance IsStableUnderCobaseChange.monomorphisms : IsStableUnderCobaseChange (monomorphisms SSet) where
  of_isPushout {_ _ _ _ f _ _ _} P hf :=
    letI _ : Mono f := hf
    letI _ : Adhesive SSet := adhesive_functor
    Adhesive.mono_of_isPushout_of_mono_right P

instance IsStableUnderTransfiniteComposition.monomorphisms :
    IsStableUnderTransfiniteComposition.{u} (monomorphisms SSet.{u}) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    change (MorphismProperty.monomorphisms (_ ⥤ _)).IsStableUnderTransfiniteCompositionOfShape _
    infer_instance

-- `0077` (a) monomorphisms are weakly saturated
instance monomorphisms.WeaklySaturated : WeaklySaturated.{u} (monomorphisms SSet.{u}) :=
  ⟨ IsStableUnderCobaseChange.monomorphisms,
    IsStableUnderRetracts.monomorphisms,
    by infer_instance,
    IsStableUnderTransfiniteComposition.monomorphisms⟩

/-- `modelCategoryQuillen.transfiniteCompositionOfMono` -/
noncomputable def transfiniteCompositionOfMono_bdryInclusions {X Y : SSet.{u}} (i : X ⟶ Y) [Mono i] :
    (coproducts.{u} bdryInclusions).pushouts.TransfiniteCompositionOfShape ℕ i where
  toTransfiniteCompositionOfShape :=
    (relativeCellComplexOfMono i).toTransfiniteCompositionOfShape
  map_mem d hd := by
    apply pushouts_monotone _ _
      ((relativeCellComplexOfMono i).attachCells d hd).pushouts_coproducts
    apply coproducts_monotone
    rintro _ _ _ ⟨⟩
    exact .mk d

/-- `modelCategoryQuillen.transfiniteCompositions_pushouts_coproducts` -/
lemma transfiniteCompositions_pushouts_coproducts_bdryInclusions :
    transfiniteCompositions.{u} (coproducts.{u} bdryInclusions).pushouts = monomorphisms SSet.{u} := by
  apply le_antisymm
  · rw [transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact brdyInclusions_le_monomorphisms
  · intro _ _ i (_ : Mono i)
    apply transfiniteCompositionsOfShape_le_transfiniteCompositions _ (ULift ℕ)
    exact ⟨(transfiniteCompositionOfMono_bdryInclusions i).ofOrderIso (orderIsoULift.{u} ℕ).symm⟩

/-- `0077` (b) monomorphisms are generated by boundary inclusions. -/
lemma monomorphism_eq_saturation_bdryInclusions :
    monomorphisms SSet.{u} = saturation.{u} bdryInclusions := by
  apply le_antisymm
  · rw [← transfiniteCompositions_pushouts_coproducts_bdryInclusions,
      transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact le_saturation bdryInclusions
  · rw [← WeaklySaturated.le_iff]
    intro _ _ _ ⟨n⟩
    exact monomorphisms.infer_property _

/-- `006Y` trivial fibration iff rlp wrt all monomorphisms -/
lemma trivialFibration_eq_rlp_monomorphisms :
    trivialFibration = (monomorphisms SSet).rlp:= by
  apply le_antisymm
  · rw [← le_llp_iff_le_rlp, monomorphism_eq_saturation_bdryInclusions,
      ← WeaklySaturated.le_iff]
    exact le_llp_rlp bdryInclusions
  · exact antitone_rlp brdyInclusions_le_monomorphisms

/-- `006Z` (a), trivial fibrations are split epimorphisms -/
noncomputable
instance splitEpi_of_trivialFibration {X Y : SSet} {p : X ⟶ Y} (hp : trivialFibration p) : SplitEpi p := by
  rw [trivialFibration_eq_rlp_monomorphisms] at hp
  exact splitEpi_of_monomorphisms_rlp hp

/-- inner anodyne morphisms are monomorphisms -/
lemma innerAnodyne_le_monomorphisms : innerAnodyne ≤ monomorphisms SSet := by
  rw [innerAnodyne_eq_saturation_innerHornInclusions, ← WeaklySaturated.le_iff]
  exact fun _ _ _ ⟨_, _⟩ ↦ monomorphisms.infer_property _

end SSet
