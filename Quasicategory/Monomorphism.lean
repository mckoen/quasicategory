import Quasicategory.Basic
import Quasicategory.InternalHom
import Mathlib.CategoryTheory.Adhesive
import Mathlib.CategoryTheory.MorphismProperty.FunctorCategory
import Mathlib.CategoryTheory.Types.Monomorphisms
import Quasicategory.TopCatModelCategory.SSet.Skeleton

universe w v u

namespace SSet

open CategoryTheory Simplicial MorphismProperty MonoidalCategory

open MonoidalCategory in
/-- B ‚äó ‚àÇŒî[n] ‚ü∂ B ‚äó Œî[n] is a monomorphism. Should be generalized. -/
instance boundaryInclusion_whisker_mono (B : SSet) (n : ‚Ñï) : Mono (B ‚óÅ (boundary n).Œπ) := by
  have : ‚àÄ (k : SimplexCategory·µí·µñ), Mono ((B ‚óÅ (boundary n).Œπ).app k) := by
    intro k
    rw [mono_iff_injective]
    rintro ‚ü®b, x‚ü© ‚ü®b', x'‚ü© h
    apply Prod.ext_iff.1 at h
    apply Prod.ext
    ¬∑ exact h.1
    ¬∑ simp only [boundary, whiskerLeft_app_apply] at h ‚ä¢
      apply (Set.injective_codRestrict Subtype.property).mp
      exact fun ‚¶Éa‚ÇÅ a‚ÇÇ‚¶Ñ a ‚Ü¶ a
      exact h.2
  apply NatTrans.mono_of_mono_app

instance IsStableUnderCobaseChange.monomorphisms : IsStableUnderCobaseChange (monomorphisms SSet) where
  of_isPushout {_ _ _ _ f _ _ _} P hf :=
    --intro A B A' B' f s f' t P hf
    letI _ : Mono f := hf
    letI _ : Adhesive SSet := adhesive_functor
    Adhesive.mono_of_isPushout_of_mono_right P

instance IsStableUnderTransfiniteComposition.monomorphisms :
    IsStableUnderTransfiniteComposition.{u} (monomorphisms SSet.{u}) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    change (MorphismProperty.monomorphisms (_ ‚•§ _)).IsStableUnderTransfiniteCompositionOfShape _
    infer_instance

-- `0077` (a) monomorphisms are weakly saturated
instance monomorphisms.WeaklySaturated : WeaklySaturated.{u} (monomorphisms SSet.{u}) :=
  ‚ü® IsStableUnderCobaseChange.monomorphisms,
    IsStableUnderRetracts.monomorphisms,
    IsStableUnderTransfiniteComposition.monomorphisms‚ü©

open modelCategoryQuillen in
/-- `0077` (b) monomorphisms are generated by boundary inclusions. -/
lemma mono_eq_bdryInclusions : monomorphisms SSet.{u} = saturation.{u} bdryInclusions := by
  apply le_antisymm
  ¬∑ rw [‚Üê transfiniteCompositions_pushouts_coproducts.{u}, transfiniteCompositions_le_iff,
      pushouts_le_iff, coproducts_le_iff]
    convert le_saturation I
    apply le_antisymm
    all_goals exact fun _ _ _ ‚ü®n‚ü© ‚Ü¶ .mk n
  ¬∑ rw [‚Üê WeaklySaturated.le_iff]
    intro _ _ _ ‚ü®n‚ü©
    exact monomorphisms.infer_property _

/-- `006Y` trivial Kan fibration iff rlp wrt all monomorphisms -/
lemma trivialKanFibration_eq_rlp_monomorphisms :
    trivialKanFibration = (monomorphisms SSet).rlp:= by
  apply le_antisymm
  ¬∑ intro _ _ _ h
    rw [morphism_rlp_iff, mono_eq_bdryInclusions, ‚Üê WeaklySaturated.le_iff]
    intro _ _ _ hf _ _ _ ‚ü®‚ü©
    exact h _ hf
  ¬∑ apply antitone_rlp
    intro _ _ _ ‚ü®n‚ü©
    exact monomorphisms.infer_property _

/-- `006Z`(a), trivial Kan fibrations admit sections -/
noncomputable
def trivialKanFibration_section {X Y : SSet} (p : X ‚ü∂ Y)
    (hp : trivialKanFibration p) : Y ‚ü∂ X := by
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  have : (emptyIsInitial.to X) ‚â´ p = (emptyIsInitial.to Y) ‚â´ (ùüô Y) :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  exact ((hp _ (initial_mono Y emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some.l

/-- the above map is a section -/
lemma trivialKanFibration_section_comp {X Y : SSet} (p : X ‚ü∂ Y) (hp : trivialKanFibration p) :
    trivialKanFibration_section p hp ‚â´ p = ùüô Y := by
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  have : (emptyIsInitial.to X) ‚â´ p = (emptyIsInitial.to Y) ‚â´ (ùüô Y) :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  exact ((hp _ (initial_mono Y emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some.fac_right

/-
/-- `050J` (1) -/
instance kanComplex_of_trivialKanFibration {X Y : SSet.{0}}
    (p : X ‚ü∂ Y) (hp : trivialKanFibration p) :
    KanComplex X ‚Üí KanComplex Y := by
  intro h
  constructor --no longer works because Kan complex definition is no longer simple to work with
  intro n i œÉ‚ÇÄ
  rw [trivialKanFibration_eq_rlp_monomorphisms.{w}] at hp
  dsimp [rlp] at hp
  have : (emptyIsInitial.to X) ‚â´ p = (emptyIsInitial.to Œõ[n, i]) ‚â´ œÉ‚ÇÄ :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  have œÑ‚ÇÄ := ((hp _ (initial_mono Œõ[n, i] emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some
  obtain ‚ü®œÑ, hœÑ‚ü© := h.hornFilling œÑ‚ÇÄ.l
  use œÑ ‚â´ p
  rw [‚Üê Category.assoc, ‚Üê hœÑ, œÑ‚ÇÄ.fac_right]
-/

/-- `050J` (3) --/
instance quasicategory_of_trivialKanFibration {X Y : SSet.{0}}
    (p : X ‚ü∂ Y) (hp : trivialKanFibration p) :
    Quasicategory X ‚Üí Quasicategory Y := by
  intro h
  constructor
  intro n i œÉ‚ÇÄ h0 hn
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  dsimp [rlp] at hp
  have : (emptyIsInitial.to X) ‚â´ p = (emptyIsInitial.to Œõ[n + 2, i]) ‚â´ œÉ‚ÇÄ :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  have œÑ‚ÇÄ := ((hp _ (initial_mono Œõ[n + 2, i] emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some
  obtain ‚ü®œÑ, hœÑ‚ü© := h.hornFilling h0 hn œÑ‚ÇÄ.l
  use œÑ ‚â´ p
  rw [‚Üê Category.assoc, ‚Üê hœÑ, œÑ‚ÇÄ.fac_right]

/-- inner anodyne morphisms are monomorphisms -/
lemma innerAnodyne_mono : innerAnodyne ‚â§ monomorphisms SSet := by
  rw [innerAnodyne_eq, ‚Üê WeaklySaturated.le_iff]
  intro _ _ _ ‚ü®_, _‚ü©
  exact monomorphisms.infer_property _

end SSet
