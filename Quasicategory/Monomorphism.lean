import Quasicategory.Basic
import Quasicategory.InternalHom
import Mathlib.CategoryTheory.Adhesive
import Mathlib.CategoryTheory.MorphismProperty.FunctorCategory
import Mathlib.CategoryTheory.Types.Monomorphisms
import Quasicategory.TopCatModelCategory.SSet.Skeleton

universe w v u

namespace SSet

open CategoryTheory Simplicial MorphismProperty MonoidalCategory

/-- boundary inclusions are monomorphisms. -/
instance boundaryInclusion_mono (n : â„•) : Mono (boundary n).Î¹ := instMonoÎ¹ âˆ‚Î”[n]

/-- horn inclusions are monomorphisms. -/
instance hornInclusion_mono (n : â„•) (i : Fin (n + 1)) : Mono (horn n i).Î¹ := instMonoÎ¹ Î›[n, i]

-- inner horn inclusions are monomorphisms
instance innerHornInclusion_mono â¦ƒn : â„•â¦„ â¦ƒi : Fin (n + 3)â¦„ (_h0 : 0 < i) (_hn : i < Fin.last (n+2)) :
    monomorphisms SSet (horn (n + 2) i).Î¹ := hornInclusion_mono _ _

open MonoidalCategory in
/-- B âŠ— âˆ‚Î”[n] âŸ¶ B âŠ— Î”[n] is a monomorphism. Should be generalized. -/
instance boundaryInclusion_whisker_mono (B : SSet) (n : â„•) : Mono (B â— (boundary n).Î¹) := by
  have : âˆ€ (k : SimplexCategoryáµ’áµ–), Mono ((B â— (boundary n).Î¹).app k) := by
    intro k
    rw [mono_iff_injective]
    rintro âŸ¨b, xâŸ© âŸ¨b', x'âŸ© h
    apply Prod.ext_iff.1 at h
    apply Prod.ext
    Â· exact h.1
    Â· simp only [boundary, whiskerLeft_app_apply] at h âŠ¢
      apply (Set.injective_codRestrict Subtype.property).mp
      exact fun â¦ƒaâ‚ aâ‚‚â¦„ a â†¦ a
      exact h.2
  apply NatTrans.mono_of_mono_app

instance IsStableUnderCobaseChange.monomorphisms : IsStableUnderCobaseChange (monomorphisms SSet) := by
  refine âŸ¨?_âŸ©
  intro A B A' B' f s f' t P hf
  letI _ : Mono f := hf
  letI _ : Adhesive SSet := adhesive_functor
  exact Adhesive.mono_of_isPushout_of_mono_right P

instance IsStableUnderTransfiniteComposition.monomorphisms :
    IsStableUnderTransfiniteComposition.{u} (monomorphisms (SSet.{u})) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    change (MorphismProperty.monomorphisms (_ â¥¤ _)).IsStableUnderTransfiniteCompositionOfShape _
    infer_instance

-- `0077` (a) monomorphisms are weakly saturated
instance monomorphisms.WeaklySaturated : WeaklySaturated.{u} (monomorphisms SSet.{u}) :=
  âŸ¨ IsStableUnderCobaseChange.monomorphisms,
    IsStableUnderRetracts.monomorphisms,
    IsStableUnderTransfiniteComposition.monomorphismsâŸ©

open modelCategoryQuillen in
/-- `0077` (b) monomorphisms are generated by boundary inclusions. -/
lemma mono_eq_bdryInclusions : monomorphisms SSet.{u} = WeaklySaturatedClassOf.{u} BoundaryInclusions := by
  apply le_antisymm
  Â· rw [â† transfiniteCompositions_pushouts_coproducts.{u}, transfiniteCompositions_le_iff,
      pushouts_le_iff, coproducts_le_iff]
    convert le_WeaklySaturatedClassOf I
    apply le_antisymm
    all_goals exact fun _ _ _ âŸ¨nâŸ© â†¦ .mk n
  Â· refine minimalWeaklySaturated _ _ ?_ (by infer_instance)
    intro _ _ f hf
    cases hf
    exact monomorphisms.infer_property _

/-- `006Y` trivial Kan fibration iff rlp wrt all monomorphisms -/
lemma trivialKanFibration_eq_rlp_monomorphisms :
    trivialKanFibration = (monomorphisms SSet).rlp:= by
  ext X Y p
  refine âŸ¨?_, ?_âŸ©
  Â· intro h
    rw [class_rlp_iff_llp_morphism, mono_eq_bdryInclusions]
    intro _ _ i hi
    refine minimalWeaklySaturated (MorphismClass p).llp BoundaryInclusions ?_ (llp.WeaklySaturated _) i hi
    intro _ _ _ hf _ _ _ hg
    induction hg with | mk => exact h _ hf
  Â· intro h _ _ p hp
    induction hp
    exact h _ (boundaryInclusion_mono _)

/-- `006Z`(a), trivial Kan fibrations admit sections -/
noncomputable
def trivialKanFibration_section {X Y : SSet} (p : X âŸ¶ Y)
    (hp : trivialKanFibration p) : Y âŸ¶ X := by
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  have : (emptyIsInitial.to X) â‰« p = (emptyIsInitial.to Y) â‰« (ðŸ™ Y) :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  exact ((hp _ (initial_mono Y emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some.l

/-- the above map is a section -/
lemma trivialKanFibration_section_comp {X Y : SSet} (p : X âŸ¶ Y) (hp : trivialKanFibration p) :
    trivialKanFibration_section p hp â‰« p = ðŸ™ Y := by
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  have : (emptyIsInitial.to X) â‰« p = (emptyIsInitial.to Y) â‰« (ðŸ™ Y) :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  exact ((hp _ (initial_mono Y emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some.fac_right

/-
/-- `050J` (1) -/
instance kanComplex_of_trivialKanFibration {X Y : SSet.{0}}
    (p : X âŸ¶ Y) (hp : trivialKanFibration p) :
    KanComplex X â†’ KanComplex Y := by
  intro h
  constructor --no longer works because Kan complex definition is no longer simple to work with
  intro n i Ïƒâ‚€
  rw [trivialKanFibration_eq_rlp_monomorphisms.{w}] at hp
  dsimp [rlp] at hp
  have : (emptyIsInitial.to X) â‰« p = (emptyIsInitial.to Î›[n, i]) â‰« Ïƒâ‚€ :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  have Ï„â‚€ := ((hp _ (initial_mono Î›[n, i] emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some
  obtain âŸ¨Ï„, hÏ„âŸ© := h.hornFilling Ï„â‚€.l
  use Ï„ â‰« p
  rw [â† Category.assoc, â† hÏ„, Ï„â‚€.fac_right]
-/

/-- `050J` (3) --/
instance quasicategory_of_trivialKanFibration {X Y : SSet.{0}}
    (p : X âŸ¶ Y) (hp : trivialKanFibration p) :
    Quasicategory X â†’ Quasicategory Y := by
  intro h
  constructor
  intro n i Ïƒâ‚€ h0 hn
  rw [trivialKanFibration_eq_rlp_monomorphisms] at hp
  dsimp [rlp] at hp
  have : (emptyIsInitial.to X) â‰« p = (emptyIsInitial.to Î›[n + 2, i]) â‰« Ïƒâ‚€ :=
    Limits.IsInitial.hom_ext emptyIsInitial _ _
  have Ï„â‚€ := ((hp _ (initial_mono Î›[n + 2, i] emptyIsInitial)).sq_hasLift (CommSq.mk (this))).exists_lift.some
  obtain âŸ¨Ï„, hÏ„âŸ© := h.hornFilling h0 hn Ï„â‚€.l
  use Ï„ â‰« p
  rw [â† Category.assoc, â† hÏ„, Ï„â‚€.fac_right]

/-- inner anodyne morphisms are monomorphisms -/
lemma innerAnodyne_mono : innerAnodyne â‰¤ monomorphisms SSet := by
  rw [innerAnodyne_eq]
  refine minimalWeaklySaturated (monomorphisms SSet) InnerHornInclusions ?_ monomorphisms.WeaklySaturated
  intro _ _ _ h
  induction h with | mk => exact hornInclusion_mono _ _

end SSet
