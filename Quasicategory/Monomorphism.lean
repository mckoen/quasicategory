import Quasicategory.Basic
import Quasicategory.InternalHom
import Mathlib.CategoryTheory.Adhesive
import Mathlib.CategoryTheory.MorphismProperty.FunctorCategory
import Mathlib.CategoryTheory.Types.Monomorphisms
import Quasicategory.TopCatModelCategory.SSet.Skeleton
import Mathlib.AlgebraicTopology.SimplicialSet.CategoryWithFibrations

universe w v u

namespace SSet

open CategoryTheory Simplicial MorphismProperty MonoidalCategory

open MonoidalCategory in
/-- B ‚äó ‚àÇŒî[n] ‚ü∂ B ‚äó Œî[n] is a monomorphism. Should be generalized. -/
instance boundaryInclusion_whisker_mono (B : SSet) (n : ‚Ñï) : Mono (B ‚óÅ (boundary n).Œπ) := by
  have : ‚àÄ (k : SimplexCategory·µí·µñ), Mono ((B ‚óÅ (boundary n).Œπ).app k) := by
    intro k
    rw [mono_iff_injective]
    rintro ‚ü®b, x‚ü© ‚ü®b', x'‚ü© h
    apply Prod.ext_iff.1 at h
    apply Prod.ext
    ¬∑ exact h.1
    ¬∑ simp only [boundary, whiskerLeft_app_apply] at h ‚ä¢
      apply (Set.injective_codRestrict Subtype.property).mp
      exact fun ‚¶Éa‚ÇÅ a‚ÇÇ‚¶Ñ a ‚Ü¶ a
      exact h.2
  apply NatTrans.mono_of_mono_app

instance IsStableUnderCobaseChange.monomorphisms : IsStableUnderCobaseChange (monomorphisms SSet) where
  of_isPushout {_ _ _ _ f _ _ _} P hf :=
    --intro A B A' B' f s f' t P hf
    letI _ : Mono f := hf
    letI _ : Adhesive SSet := adhesive_functor
    Adhesive.mono_of_isPushout_of_mono_right P

instance IsStableUnderTransfiniteComposition.monomorphisms :
    IsStableUnderTransfiniteComposition.{u} (monomorphisms SSet.{u}) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    change (MorphismProperty.monomorphisms (_ ‚•§ _)).IsStableUnderTransfiniteCompositionOfShape _
    infer_instance

-- `0077` (a) monomorphisms are weakly saturated
instance monomorphisms.WeaklySaturated : WeaklySaturated.{u} (monomorphisms SSet.{u}) :=
  ‚ü® IsStableUnderCobaseChange.monomorphisms,
    IsStableUnderRetracts.monomorphisms,
    by infer_instance,
    IsStableUnderTransfiniteComposition.monomorphisms‚ü©

open modelCategoryQuillen in
/-- `0077` (b) monomorphisms are generated by boundary inclusions. -/
lemma mono_eq_bdryInclusions : monomorphisms SSet.{u} = saturation.{u} bdryInclusions := by
  apply le_antisymm
  ¬∑ rw [‚Üê transfiniteCompositions_pushouts_coproducts.{u}, transfiniteCompositions_le_iff,
      pushouts_le_iff, coproducts_le_iff]
    convert le_saturation I
    apply le_antisymm
    all_goals exact fun _ _ _ ‚ü®n‚ü© ‚Ü¶ .mk n
  ¬∑ rw [‚Üê WeaklySaturated.le_iff]
    intro _ _ _ ‚ü®n‚ü©
    exact monomorphisms.infer_property _

/-- `006Y` trivial Kan fibration iff rlp wrt all monomorphisms -/
lemma trivialFibration_eq_rlp_monomorphisms :
    trivialFibration = (monomorphisms SSet).rlp:= by
  apply le_antisymm
  ¬∑ intro _ _ _ h
    rw [morphism_rlp_iff, mono_eq_bdryInclusions, ‚Üê WeaklySaturated.le_iff]
    intro _ _ _ hf _ _ _ ‚ü®‚ü©
    exact h _ hf
  ¬∑ apply antitone_rlp
    intro _ _ _ ‚ü®n‚ü©
    exact monomorphisms.infer_property _

/-- `006Z`(a), trivial Kan fibrations admit sections -/
noncomputable
def trivialFibration_section {X Y : SSet} (p : X ‚ü∂ Y)
    (hp : trivialFibration p) : Y ‚ü∂ X := by
  rw [trivialFibration_eq_rlp_monomorphisms] at hp
  have : (isInitialEmpty.to X) ‚â´ p = (isInitialEmpty.to Y) ‚â´ (ùüô Y) :=
    Limits.IsInitial.hom_ext isInitialEmpty _ _
  exact ((hp _ (initial_mono Y isInitialEmpty)).sq_hasLift (CommSq.mk (this))).exists_lift.some.l

/-- `006Z`(a), trivial Kan fibrations are split epimorphisms -/
noncomputable
instance {X Y : SSet} (p : X ‚ü∂ Y) (hp : trivialFibration p) : SplitEpi p where
  section_ := trivialFibration_section p hp
  id := by
    rw [trivialFibration_eq_rlp_monomorphisms] at hp
    exact ((hp _ (initial_mono Y isInitialEmpty)).sq_hasLift (CommSq.mk (isInitialEmpty.hom_ext _ _))).exists_lift.some.fac_right

namespace modelCategoryQuillen

/-- `050J` (1) -/
instance kanComplex_of_trivialFibration {X Y : SSet}
    (p : X ‚ü∂ Y) (hp : trivialFibration p) :
    KanComplex X ‚Üí KanComplex Y := by
  intro hX
  dsimp [KanComplex]
  rw [HomotopicalAlgebra.isFibrant_iff Y, modelCategoryQuillen.fibration_iff] --no longer works because Kan complex definition is no longer simple to work with
  rw [trivialFibration_eq_rlp_monomorphisms] at hp
  intro _ _ _ h
  dsimp [rlp] at hp
  obtain ‚ü®_, ‚ü®h, hw‚ü©‚ü© := h
  simp at h
  obtain ‚ü®n, _, h‚ü© := h
  have := h hw
  rw [ofHoms_iff] at this
  obtain ‚ü®i, hi‚ü© := this
  rw [Arrow.hasLiftingProperty_iff, hi, ‚Üê Arrow.hasLiftingProperty_iff]
  constructor
  intro œÉ‚ÇÄ g sq
  have : (isInitialEmpty.to X) ‚â´ p = (isInitialEmpty.to Œõ[n + 1, i].toSSet) ‚â´ œÉ‚ÇÄ := isInitialEmpty.hom_ext _ _
  have œÑ‚ÇÄ := ((hp _ (initial_mono Œõ[n + 1, i] isInitialEmpty)).sq_hasLift (CommSq.mk this)).exists_lift.some
  obtain ‚ü®œÑ, hœÑ‚ü© := hX.hornFilling œÑ‚ÇÄ.l
  constructor
  constructor
  exact ‚ü®œÑ ‚â´ p, by rw [‚Üê Category.assoc, ‚Üê hœÑ, œÑ‚ÇÄ.fac_right], Limits.terminal.hom_ext _ _‚ü©

end modelCategoryQuillen

/-- `050J` (3) --/
instance quasicategory_of_trivialFibration {X Y : SSet}
    (p : X ‚ü∂ Y) (hp : trivialFibration p) :
    Quasicategory X ‚Üí Quasicategory Y := by
  intro h
  constructor
  intro n i œÉ‚ÇÄ h0 hn
  rw [trivialFibration_eq_rlp_monomorphisms] at hp
  have : (isInitialEmpty.to X) ‚â´ p = (isInitialEmpty.to Œõ[n + 2, i]) ‚â´ œÉ‚ÇÄ :=
    isInitialEmpty.hom_ext _ _
  have œÑ‚ÇÄ := ((hp _ (initial_mono Œõ[n + 2, i] isInitialEmpty)).sq_hasLift (CommSq.mk (this))).exists_lift.some
  obtain ‚ü®œÑ, hœÑ‚ü© := h.hornFilling h0 hn œÑ‚ÇÄ.l
  use œÑ ‚â´ p
  rw [‚Üê Category.assoc, ‚Üê hœÑ, œÑ‚ÇÄ.fac_right]

/-- inner anodyne morphisms are monomorphisms -/
lemma innerAnodyne_mono : innerAnodyne ‚â§ monomorphisms SSet := by
  rw [innerAnodyne_eq, ‚Üê WeaklySaturated.le_iff]
  intro _ _ _ ‚ü®_, _‚ü©
  exact monomorphisms.infer_property _

end SSet
