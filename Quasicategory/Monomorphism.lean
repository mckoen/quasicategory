import Quasicategory.Basic
import Quasicategory.PushoutProduct.TransfiniteComposition

universe v u

open CategoryTheory Simplicial MorphismProperty Limits

namespace Types

-- by joel
instance : IsStableUnderCoproducts.{v} (monomorphisms (Type u)) where
  isStableUnderCoproductsOfShape J  := by
    apply IsStableUnderCoproductsOfShape.mk
    intro X₁ X₂ _ _ f hf
    simp only [monomorphisms.iff, mono_iff_injective] at hf ⊢
    intro x y h
    obtain ⟨⟨i⟩, x, rfl⟩ := Types.jointly_surjective_of_isColimit (coproductIsCoproduct X₁) x
    obtain ⟨⟨j⟩, y, rfl⟩ := Types.jointly_surjective_of_isColimit (coproductIsCoproduct X₁) y
    dsimp at x y h ⊢
    change (Sigma.ι X₁ i ≫ Limits.Sigma.map f) x =
      (Sigma.ι X₁ j ≫ Limits.Sigma.map f) y at h
    simp only [ι_colimMap] at h
    dsimp at h
    obtain rfl := Types.eq_cofanInj_apply_eq_of_isColimit (coproductIsCoproduct X₂) _ _ h
    obtain rfl := hf _ (Types.cofanInj_injective_of_isColimit (coproductIsCoproduct X₂) _ h)
    rfl

-- by joel
instance [HasCoproducts.{v} (Type u)] (J : Type*) [Category J] :
    IsStableUnderCoproducts.{v} (monomorphisms (J ⥤ Type u)) where
  isStableUnderCoproductsOfShape J := by
    rw [← functorCategory_monomorphisms]
    apply IsStableUnderColimitsOfShape.functorCategory
    apply isStableUnderCoproductsOfShape_of_isStableUnderCoproducts

end Types

namespace SSet

open MonoidalCategory in
instance tensorLeft_PreservesMonomorphisms (B : SSet) :
    Functor.PreservesMonomorphisms (tensorLeft B) where
  preserves _ hf := by
    rw [NatTrans.mono_iff_mono_app] at hf ⊢
    intro k
    replace hf := hf k
    rw [mono_iff_injective] at hf ⊢
    rintro ⟨b, x⟩ ⟨b', x'⟩ h
    rw [Prod.ext_iff] at h
    exact Prod.ext h.1 (hf h.2)

instance IsStableUnderCobaseChange.monomorphisms : IsStableUnderCobaseChange (monomorphisms SSet) where
  of_isPushout {_ _ _ _ f _ _ _} P hf :=
    letI _ : Mono f := hf
    letI _ : Adhesive SSet := adhesive_functor
    Adhesive.mono_of_isPushout_of_mono_right P

instance {C : Type u} [Category.{v} C] [Adhesive C] : IsStableUnderCobaseChange (monomorphisms C) where
  of_isPushout {_ _ _ _ f _ _ _} P hf :=
    letI _ : Mono f := hf
    letI _ : Adhesive SSet := adhesive_functor
    Adhesive.mono_of_isPushout_of_mono_right P

-- by joel
instance IsStableUnderTransfiniteComposition.monomorphisms :
    IsStableUnderTransfiniteComposition.{u} (monomorphisms SSet.{u}) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    change (MorphismProperty.monomorphisms (_ ⥤ _)).IsStableUnderTransfiniteCompositionOfShape _
    infer_instance

-- by joel
instance IsStableUnderCoproducts.monomorphisms :
    IsStableUnderCoproducts.{u} (monomorphisms SSet.{u}) := by
  change (MorphismProperty.monomorphisms (_ ⥤ _)).IsStableUnderCoproducts
  infer_instance

-- `0077` (a) monomorphisms are weakly saturated
instance monomorphisms.WeaklySaturated : WeaklySaturated.{u} (monomorphisms SSet.{u}) :=
  ⟨ IsStableUnderCobaseChange.monomorphisms,
    IsStableUnderRetracts.monomorphisms,
    IsStableUnderCoproducts.monomorphisms,
    IsStableUnderTransfiniteComposition.monomorphisms⟩

/-- by joel `modelCategoryQuillen.transfiniteCompositionOfMono` -/
noncomputable def transfiniteCompositionOfMono_bdryInclusions {X Y : SSet.{u}} (i : X ⟶ Y) [Mono i] :
    (coproducts.{u} bdryInclusions).pushouts.TransfiniteCompositionOfShape ℕ i where
  toTransfiniteCompositionOfShape :=
    (relativeCellComplexOfMono i).toTransfiniteCompositionOfShape
  map_mem d hd := by
    apply pushouts_monotone _ _
      ((relativeCellComplexOfMono i).attachCells d hd).pushouts_coproducts
    apply coproducts_monotone
    rintro _ _ _ ⟨⟩
    exact .mk d

/-- by joel `modelCategoryQuillen.transfiniteCompositions_pushouts_coproducts` -/
lemma transfiniteCompositions_pushouts_coproducts_bdryInclusions :
    transfiniteCompositions.{u} (coproducts.{u} bdryInclusions).pushouts = monomorphisms SSet.{u} := by
  apply le_antisymm
  · rw [transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact brdyInclusions_le_monomorphisms
  · intro _ _ i (_ : Mono i)
    apply transfiniteCompositionsOfShape_le_transfiniteCompositions _ (ULift ℕ)
    exact ⟨(transfiniteCompositionOfMono_bdryInclusions i).ofOrderIso (orderIsoULift.{u} ℕ).symm⟩

/-- `0077` (b) monomorphisms are generated by boundary inclusions. -/
lemma monomorphism_eq_saturation_bdryInclusions :
    monomorphisms SSet.{u} = saturation.{u} bdryInclusions := by
  apply le_antisymm
  · rw [← transfiniteCompositions_pushouts_coproducts_bdryInclusions,
      transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact le_saturation bdryInclusions
  · rw [← WeaklySaturated.le_iff]
    intro _ _ _ ⟨n⟩
    exact monomorphisms.infer_property _

/-- `006Y` trivial fibration iff rlp wrt all monomorphisms -/
lemma trivialFibration_eq_rlp_monomorphisms :
    trivialFibration = (monomorphisms SSet).rlp:= by
  apply le_antisymm
  · rw [← le_llp_iff_le_rlp, monomorphism_eq_saturation_bdryInclusions,
      ← WeaklySaturated.le_iff]
    exact le_llp_rlp bdryInclusions
  · exact antitone_rlp brdyInclusions_le_monomorphisms

/-- `006Z` (a), trivial fibrations are split epimorphisms -/
noncomputable
instance splitEpi_of_trivialFibration {X Y : SSet} {p : X ⟶ Y} (hp : trivialFibration p) : SplitEpi p := by
  rw [trivialFibration_eq_rlp_monomorphisms] at hp
  exact splitEpi_of_monomorphisms_rlp hp

/-- inner anodyne morphisms are monomorphisms -/
lemma innerAnodyne_le_monomorphisms : innerAnodyne ≤ monomorphisms SSet := by
  rw [innerAnodyne_eq_saturation_innerHornInclusions, ← WeaklySaturated.le_iff]
  exact fun _ _ _ ⟨_, _⟩ ↦ monomorphisms.infer_property _

end SSet
