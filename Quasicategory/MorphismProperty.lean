import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting

/-!

Defines `WeaklySaturated`.

need to update with the new API in mathlib

-/

universe w v u

namespace CategoryTheory

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

inductive Morphism {A B : C} (p : A ⟶ B) : {X Y : C} → (X ⟶ Y) → Prop
  | mk : (Morphism p) p

/-- the class of a single morphism `p`. -/
def MorphismClass {X Y : C} (p : X ⟶ Y) : MorphismProperty C := fun _ _ i ↦ (Morphism p) i

/-- a morphism `p` has rlp wrt a class `T` of morphisms iff every morphism in `T` has llp wrt `p`. -/
lemma class_rlp_iff_llp_morphism (T : MorphismProperty C) {X Y : C} (p : X ⟶ Y) : T.rlp p ↔
    ∀ {A B} (i : A ⟶ B) (_ : T i), (MorphismClass p).llp i := by
  refine ⟨fun hp _ _ _ hi _ _ _ h ↦ by induction h; exact hp _ hi, fun h _ _ i hi ↦ h i hi _ .mk⟩

/-- a morphism `p` has llp wrt a class `T` of morphisms iff every morphism in `T` has rlp wrt `p`. -/
lemma class_llp_iff_rlp_morphism (T : MorphismProperty C) {X Y : C} (p : X ⟶ Y) : T.llp p ↔
    ∀ {A B} (i : A ⟶ B) (_ : T i), (MorphismClass p).rlp i := by
  refine ⟨fun hp _ _ _ hi _ _ _ h ↦ by induction h; exact hp _ hi, fun h _ _ i hi ↦ h i hi _ .mk⟩

instance llp.IsStableUnderTransfiniteComposition {T : MorphismProperty C} :
    T.llp.IsStableUnderTransfiniteComposition := ⟨T.isStableUnderTransfiniteCompositionOfShape_llp⟩

class WeaklySaturated (P : MorphismProperty C) : Prop where
  IsStableUnderCobaseChange : P.IsStableUnderCobaseChange
  IsStableUnderRetracts : P.IsStableUnderRetracts
  IsStableUnderTransfiniteComposition : IsStableUnderTransfiniteComposition.{w, v, u} P

instance (T : MorphismProperty C) [WeaklySaturated T] : T.IsStableUnderCoproducts := sorry

instance llp.WeaklySaturated (T : MorphismProperty C) : WeaklySaturated T.llp :=
  ⟨T.llp_isStableUnderCobaseChange, T.llp_isStableUnderRetracts, llp.IsStableUnderTransfiniteComposition⟩

/-- weakly saturated classes contain all isomorphisms. -/
lemma WeaklySaturated_contains_iso {X Y} (T : MorphismProperty C) [hT: WeaklySaturated T] (p : X ⟶ Y) :
    (isomorphisms C) p → T p := fun hp ↦
  letI : IsIso p := hp
  letI : T.IsStableUnderTransfiniteComposition := hT.IsStableUnderTransfiniteComposition
  letI h : T.IsMultiplicative := by infer_instance
  hT.IsStableUnderCobaseChange.of_isPushout (IsPushout.of_vert_isIso ⟨rfl⟩) (h.id_mem X)

-- inductive type defining the weakly saturated class generated by a morphism property
inductive WeaklySaturatedOf (T : MorphismProperty C) : {X Y : C} → (X ⟶ Y) → Prop
  | of ⦃X Y : C⦄ (f : X ⟶ Y) (h : T f) : WeaklySaturatedOf T f
  | pushout ⦃X Y Z W : C⦄ ⦃f : X ⟶ Y⦄ ⦃g : X ⟶ Z⦄ ⦃inl : Z ⟶ W⦄ ⦃inr : Y ⟶ W⦄ (_ : IsPushout g f inl inr) : WeaklySaturatedOf T f → WeaklySaturatedOf T inl
  | retract ⦃X Y Z W : C⦄ ⦃f : X ⟶ Y⦄ ⦃g : Z ⟶ W⦄ (_ : RetractArrow f g) : WeaklySaturatedOf T g → WeaklySaturatedOf T f
  | transfinite (J : Type w) [LinearOrder J] [SuccOrder J] [OrderBot J] [WellFoundedLT J]
      {X Y : C} (f : X ⟶ Y) (hf : CategoryTheory.TransfiniteCompositionOfShape J f) :
        (∀ (j : J), (hj : ¬IsMax j) → WeaklySaturatedOf T (hf.F.map (homOfLE (Order.le_succ j)))) → WeaklySaturatedOf T f

/-- the weakly saturated class generated by a morphism property. -/
def WeaklySaturatedClassOf (T : MorphismProperty C) : MorphismProperty C := fun _ _ f ↦ WeaklySaturatedOf.{w} T f

-- do galois connection, galois insertion

instance of_is (T : MorphismProperty C) : WeaklySaturated.{w, v, u} (WeaklySaturatedClassOf.{w, v, u} T) where
  IsStableUnderCobaseChange := ⟨fun h hf ↦ .pushout h hf⟩
  IsStableUnderRetracts := ⟨fun h hf ↦ .retract h hf⟩
  IsStableUnderTransfiniteComposition := {
    isStableUnderTransfiniteCompositionOfShape := fun J _ _ _ _ ↦
      ⟨fun _ _ f hf ↦ .transfinite J f _ hf.some.map_mem⟩}

instance (T : MorphismProperty C) : T.WeaklySaturatedClassOf.IsStableUnderCobaseChange :=
  T.of_is.IsStableUnderCobaseChange

instance (T : MorphismProperty C) : IsStableUnderTransfiniteComposition.{w, v, u} (WeaklySaturatedClassOf.{w, v, u} T) :=
  (of_is.{w, v, u} T).IsStableUnderTransfiniteComposition

lemma le_WeaklySaturatedClassOf (T : MorphismProperty C) : T ≤ WeaklySaturatedClassOf T := .of

lemma WeaklySaturatedClassOf_ext (S T : MorphismProperty C) :
    S = T → WeaklySaturatedClassOf.{w, v, u} S = WeaklySaturatedClassOf.{w, v, u} T := by
  intro h
  rw [h]

/-- if S is any other wsc containing T, then it contains the class generated by T. -/
lemma minimalWeaklySaturated (S T : MorphismProperty C) (h : T ≤ S) : WeaklySaturated.{w} S → (WeaklySaturatedClassOf.{w} T) ≤ S := by
  intro hS X Y f hf
  induction hf with
  | of f hf => exact h _ hf
  | pushout h _ hf => exact hS.IsStableUnderCobaseChange.of_isPushout h hf
  | retract h _ hf => exact hS.IsStableUnderRetracts.of_retract h hf
  | transfinite J f hF h' h'' =>
    refine (hS.IsStableUnderTransfiniteComposition.isStableUnderTransfiniteCompositionOfShape J).le _ ⟨hF, h''⟩

lemma transfinite_pushouts_coproducts_eq (T : MorphismProperty C) :
    transfiniteCompositions.{w, v, u} (coproducts.{w, v, u} T).pushouts = WeaklySaturatedClassOf.{w, v, u} T := by
  apply le_antisymm
  · rw [transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact le_WeaklySaturatedClassOf T
  · intro _ _ f hf
    cases hf with
    | of f h => exact le_transfiniteCompositions _ f (le_pushouts _ f (le_coproducts T f h))
    | @pushout A B _ _ p i _ q h hp =>
      apply le_transfiniteCompositions
      dsimp [pushouts]
      refine ⟨A, B, p, i, q, ?_, h⟩
      apply le_coproducts
      sorry
    | retract _ _ => sorry
    | transfinite J f hf _ => sorry

end MorphismProperty

end CategoryTheory
