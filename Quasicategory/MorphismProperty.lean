import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting
import Mathlib.SetTheory.Cardinal.Order
import Mathlib.CategoryTheory.SmallObject.Basic
import Quasicategory.PushoutProduct.Basic

universe w v u

namespace CategoryTheory

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

variable (T : MorphismProperty C)

inductive Morphism {X Y : C} (p : X ‚ü∂ Y) : {A B : C} ‚Üí (A ‚ü∂ B) ‚Üí Prop
  | mk : (Morphism p) p

section Morphism

variable {X Y : C} (p : X ‚ü∂ Y)

/-- the class of a single morphism `p`. -/
def morphism : MorphismProperty C := fun _ _ i ‚Ü¶ (Morphism p) i

/-- a morphism `p` has rlp wrt a class `T` of morphisms iff every morphism in `T` has llp wrt `p`. -/
lemma morphism_rlp_iff : T.rlp p ‚Üî T ‚â§ (morphism p).llp :=
  ‚ü®fun hp _ _ _ hi _ _ _ ‚ü®‚ü© ‚Ü¶ hp _ hi, fun h _ _ i hi ‚Ü¶ h i hi _ .mk‚ü©

lemma morphism_llp_iff : T.llp p ‚Üî T ‚â§ (morphism p).rlp :=
  ‚ü®fun hp _ _ _ hi _ _ _ ‚ü®‚ü© ‚Ü¶ hp _ hi, fun h _ _ i hi ‚Ü¶ h i hi _ .mk‚ü©

lemma morphism_le_iff : morphism p ‚â§ T ‚Üî T p :=
  ‚ü®fun h ‚Ü¶ h _ .mk, fun h _ _ _ ‚ü®‚ü© ‚Ü¶ h‚ü©

end Morphism

section LiftingProperty

open Limits

variable {X Y : C} {p : X ‚ü∂ Y}

variable [HasInitial C] [InitialMonoClass C]

@[simp]
noncomputable
def _root_.CategoryTheory.HasLiftingProperty.section_of_initial_to_left
    (h : HasLiftingProperty (initial.to Y) p) : Y ‚ü∂ X :=
  (h.sq_hasLift (CommSq.mk (initial.hom_ext (initial.to X ‚â´ p) (initial.to Y ‚â´ ùüô Y)))).exists_lift.some.l

noncomputable
instance splitEpi_of_monomorphisms_rlp
    (hp : (monomorphisms C).rlp p) : SplitEpi p where
  section_ := (hp _ (initial.mono_from _ _)).section_of_initial_to_left
  id := CategoryTheory.CommSq.LiftStruct.fac_right _

end LiftingProperty

section Saturated

class Saturated : Prop where
  IsStableUnderCobaseChange : T.IsStableUnderCobaseChange
  IsStableUnderRetracts : T.IsStableUnderRetracts
  IsStableUnderCoproducts : IsStableUnderCoproducts.{w} T
  IsStableUnderTransfiniteComposition : IsStableUnderTransfiniteComposition.{w} T

instance [h : T.Saturated] : T.IsStableUnderCobaseChange :=
  h.IsStableUnderCobaseChange

instance [h : T.Saturated] : T.IsStableUnderRetracts :=
  h.IsStableUnderRetracts

instance [h : Saturated.{w} T] : IsStableUnderTransfiniteComposition.{w} T :=
  h.IsStableUnderTransfiniteComposition

instance [h : Saturated.{w} T] : IsStableUnderCoproducts.{w} T :=
  h.IsStableUnderCoproducts

instance llp_isSaturated : Saturated T.llp :=
  ‚ü®T.llp_isStableUnderCobaseChange, T.llp_isStableUnderRetracts, ‚ü®T.llp_isStableUnderCoproductsOfShape‚ü©, ‚ü®T.isStableUnderTransfiniteCompositionOfShape_llp‚ü©‚ü©

/-- weakly saturated classes contain all isomorphisms. -/
lemma Saturated.isomorphisms_le [Saturated T] :
    isomorphisms C ‚â§ T := fun _ _ p hp ‚Ü¶
  letI : IsIso p := hp
  Saturated.IsStableUnderCobaseChange.of_isPushout (IsPushout.of_vert_isIso ‚ü®rfl‚ü©) (ContainsIdentities.id_mem _)

open Limits in
/-- inductive type defining the weakly saturated class generated by a morphism property -/
inductive SaturatedClass (T : MorphismProperty C) : {X Y : C} ‚Üí (X ‚ü∂ Y) ‚Üí Prop
  | of ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y) (h : T f) : SaturatedClass T f
  | pushout ‚¶ÉX Y Z W : C‚¶Ñ ‚¶Éf : X ‚ü∂ Y‚¶Ñ ‚¶Ég : X ‚ü∂ Z‚¶Ñ ‚¶Éinl : Z ‚ü∂ W‚¶Ñ ‚¶Éinr : Y ‚ü∂ W‚¶Ñ (_ : IsPushout g f inl inr) : SaturatedClass T f ‚Üí SaturatedClass T inl
  | retract ‚¶ÉX Y Z W : C‚¶Ñ ‚¶Éf : X ‚ü∂ Y‚¶Ñ ‚¶Ég : Z ‚ü∂ W‚¶Ñ (_ : RetractArrow f g) : SaturatedClass T g ‚Üí SaturatedClass T f
  | coproduct (J : Type w) (X‚ÇÅ X‚ÇÇ : Discrete J ‚•§ C) (c‚ÇÅ : Cocone X‚ÇÅ) (c‚ÇÇ : Cocone X‚ÇÇ) (h‚ÇÅ : IsColimit c‚ÇÅ) (_ : IsColimit c‚ÇÇ)
      (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) : (_ : ‚àÄ (j : Discrete J), (SaturatedClass T) (f.app j)) ‚Üí SaturatedClass T (h‚ÇÅ.desc (Cocone.mk _ (f ‚â´ c‚ÇÇ.Œπ)))
  | transfinite (J : Type w) [LinearOrder J] [SuccOrder J] [OrderBot J] [WellFoundedLT J]
      {X Y : C} (f : X ‚ü∂ Y) (hf : CategoryTheory.TransfiniteCompositionOfShape J f) :
        (‚àÄ (j : J), (hj : ¬¨IsMax j) ‚Üí SaturatedClass T (hf.F.map (homOfLE (Order.le_succ j)))) ‚Üí SaturatedClass T f

/-- the weakly saturated class generated by a morphism property. -/
def saturation : MorphismProperty C := fun _ _ f ‚Ü¶ SaturatedClass.{w} T f

-- do galois connection, galois insertion

instance (T : MorphismProperty C) : Saturated.{w} (saturation.{w} T) where
  IsStableUnderCobaseChange := ‚ü®fun h hf ‚Ü¶ .pushout h hf‚ü©
  IsStableUnderRetracts := ‚ü®fun h hf ‚Ü¶ .retract h hf‚ü©
  IsStableUnderCoproducts := ‚ü®fun J _ _ _ _ _ h‚ÇÇ f hf ‚Ü¶
    .coproduct J _ _ _ _ _ h‚ÇÇ f hf‚ü©
  IsStableUnderTransfiniteComposition := ‚ü®fun J _ _ _ _ ‚Ü¶
    ‚ü®fun _ _ f hf ‚Ü¶ .transfinite J f _ hf.some.map_mem‚ü©‚ü©

lemma le_saturation : T ‚â§ T.saturation := .of

lemma Saturated.le_iff (S : MorphismProperty C) [Saturated.{w} S] : T ‚â§ S ‚Üî (saturation.{w} T) ‚â§ S := by
  constructor
  ¬∑ intro h _ _ f hf
    induction hf with
    | of f hf => exact h _ hf
    | pushout h _ hf => exact Saturated.IsStableUnderCobaseChange.of_isPushout h hf
    | retract h _ hf => exact Saturated.IsStableUnderRetracts.of_retract h hf
    | coproduct J X‚ÇÅ X‚ÇÇ c‚ÇÅ c‚ÇÇ h‚ÇÅ h‚ÇÇ f hf hs =>
      exact (Saturated.IsStableUnderCoproducts.isStableUnderCoproductsOfShape J).colimitsOfShape_le _ ‚ü®X‚ÇÅ, X‚ÇÇ, c‚ÇÅ, c‚ÇÇ, h‚ÇÅ, h‚ÇÇ, f, hs‚ü©
    | transfinite J f hF h' h'' =>
      exact (Saturated.IsStableUnderTransfiniteComposition.isStableUnderTransfiniteCompositionOfShape J).le _ ‚ü®hF, h''‚ü©
  ¬∑ exact T.le_saturation.trans

lemma llp_rlp_eq_saturation {T : MorphismProperty C} [HasSmallObjectArgument.{w} T] :
    T.rlp.llp = saturation.{w} T := by
  apply le_antisymm
  ¬∑ rw [llp_rlp_of_hasSmallObjectArgument, retracts_le_iff,
      transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact le_saturation _
  ¬∑ rw [‚Üê Saturated.le_iff]
    exact T.le_llp_rlp

lemma saturation_saturation_eq {T : MorphismProperty C} :
    saturation.{w} (saturation.{w} T) = saturation.{w} T := by
  apply le_antisymm
  ¬∑ rw [‚Üê Saturated.le_iff]
  ¬∑ exact le_saturation _

section PushoutProduct

open PushoutProduct MonoidalCategory Limits

variable [MonoidalCategory C] [HasPushouts C]

variable {A B : C} (Œπ : A ‚ü∂ B)

/-- `T.pushoutProduct Œπ` is the class of all morphisms `i` such that `Œπ ‚ñ° i` is in `T`. -/
@[simp]
def pushoutProduct : MorphismProperty C := fun _ _ i ‚Ü¶ T (Œπ ‚ñ° i)

variable [‚àÄ S : C, Limits.PreservesColimitsOfSize (tensorLeft S)]

instance [T.IsStableUnderCobaseChange] : IsStableUnderCobaseChange (T.pushoutProduct Œπ) where
  of_isPushout h hg := by
    dsimp
    exact IsStableUnderCobaseChange.of_isPushout (leftFunctor_map_preserves_pushouts Œπ h) hg

instance [T.IsStableUnderRetracts] : IsStableUnderRetracts (T.pushoutProduct Œπ) where
  of_retract h hg := by
    dsimp
    exact IsStableUnderRetracts.of_retract (Retract.map h (leftFunctor Œπ)) hg

instance [IsStableUnderCoproducts.{w} T] : IsStableUnderCoproducts.{w} (T.pushoutProduct Œπ) where
  isStableUnderCoproductsOfShape J := by
    refine (isStableUnderColimitsOfShape_iff_colimitsOfShape_le _ (Discrete J)).mpr ?_
    intro X Y f hf
    cases hf with
    | mk X‚ÇÅ X‚ÇÇ c‚ÇÅ c‚ÇÇ h‚ÇÅ h‚ÇÇ f hf =>
    dsimp only [pushoutProduct]
    dsimp only [MorphismProperty.functorCategory, pushoutProduct] at hf
    apply (IsStableUnderCoproducts.isStableUnderCoproductsOfShape J).colimitsOfShape_le
    let Œ± := h‚ÇÅ.desc { pt := c‚ÇÇ.pt, Œπ := f ‚â´ c‚ÇÇ.Œπ }
    let f' := descFunctor f Œπ
    let c‚ÇÅ' := c‚ÇÅ' Œπ c‚ÇÇ h‚ÇÅ f
    let h‚ÇÅ' : Limits.IsColimit c‚ÇÅ' := c‚ÇÅ'_isColimit Œπ c‚ÇÇ h‚ÇÅ h‚ÇÇ f
    let c‚ÇÇ' := (tensorLeft B).mapCocone c‚ÇÇ
    let h‚ÇÇ' : Limits.IsColimit c‚ÇÇ' := Limits.isColimitOfPreserves (tensorLeft B) h‚ÇÇ
    convert colimitsOfShape.mk (natTransLeftFunctor f Œπ) (X‚ÇÇ ‚ãô tensorLeft B) c‚ÇÅ' c‚ÇÇ' h‚ÇÅ' h‚ÇÇ' f' hf
    convert h‚ÇÅ'.uniq _ _ _
    ¬∑ rfl
    ¬∑ rfl
    ¬∑ intro j
      dsimp only [c‚ÇÅ', PushoutProduct.c‚ÇÅ', c‚ÇÇ', f', descFunctor, tensorLeft, curriedTensor,
        Functor.mapCocone]
      simp [Functor.PushoutObjObj.Œπ]
      apply pushout.hom_ext
      ¬∑ simp [‚Üê MonoidalCategory.whiskerLeft_comp]
      ¬∑ simp [whisker_exchange]

open Limits in
instance [T.IsStableUnderCobaseChange] [IsStableUnderTransfiniteComposition.{w} T] : IsStableUnderTransfiniteComposition.{w} (T.pushoutProduct Œπ) where
  isStableUnderTransfiniteCompositionOfShape J _ _ _ _ := by
    rw [isStableUnderTransfiniteCompositionOfShape_iff.{w}]
    intro X Y f' ‚ü®hf‚ü©
    apply T.transfiniteCompositions_le
    rw [transfiniteCompositions_iff]
    refine ‚ü®J, _, _, _, _, ‚ü®(leftFunctor_preserves_transfiniteComposition J Œπ f' hf.1), ?_‚ü©‚ü©

    intro j hj
    dsimp only [leftFunctor_preserves_transfiniteComposition]
    exact IsStableUnderCobaseChange.of_isPushout (newPushoutIsPushout Œπ hf.F (Cocone.mk _ hf.incl) j) (hf.map_mem j hj)

instance [Saturated.{w} T]
      [‚àÄ (S : C), PreservesColimitsOfSize.{w, w, v, v, u, u} (tensorLeft S)] :
    Saturated.{w} (T.pushoutProduct Œπ) where
  IsStableUnderCobaseChange := by infer_instance
  IsStableUnderRetracts := by infer_instance
  IsStableUnderCoproducts := by infer_instance
  IsStableUnderTransfiniteComposition := by infer_instance

end PushoutProduct

end Saturated

end MorphismProperty

end CategoryTheory
