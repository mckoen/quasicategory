import Mathlib.CategoryTheory.MorphismProperty.TransfiniteComposition
import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting
import Mathlib.CategoryTheory.MorphismProperty.LiftingProperty

/-!

Defines `WeaklySaturated`.

need to update with the new API in mathlib

-/

universe w v u

namespace CategoryTheory

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

inductive Morphism {A B : C} (p : A âŸ¶ B) : {X Y : C} â†’ (X âŸ¶ Y) â†’ Prop
  | mk : (Morphism p) p

/-- the class of a single morphism `p`. -/
def MorphismClass {X Y : C} (p : X âŸ¶ Y) : MorphismProperty C := fun _ _ i â†¦ (Morphism p) i

/-- a morphism `p` has rlp wrt a class `T` of morphisms iff every morphism in `T` has llp wrt `p`. -/
lemma class_rlp_iff_llp_morphism (T : MorphismProperty C) {X Y : C} (p : X âŸ¶ Y) : T.rlp p â†”
    âˆ€ {A B} (i : A âŸ¶ B) (_ : T i), (MorphismClass p).llp i := by
  refine âŸ¨fun hp _ _ _ hi _ _ _ h â†¦ by induction h; exact hp _ hi, fun h _ _ i hi â†¦ h i hi _ .mkâŸ©

/-- a morphism `p` has llp wrt a class `T` of morphisms iff every morphism in `T` has rlp wrt `p`. -/
lemma class_llp_iff_rlp_morphism (T : MorphismProperty C) {X Y : C} (p : X âŸ¶ Y) : T.llp p â†”
    âˆ€ {A B} (i : A âŸ¶ B) (_ : T i), (MorphismClass p).rlp i := by
  refine âŸ¨fun hp _ _ _ hi _ _ _ h â†¦ by induction h; exact hp _ hi, fun h _ _ i hi â†¦ h i hi _ .mkâŸ©

instance llp.IsStableUnderTransfiniteComposition {T : MorphismProperty C} :
    T.llp.IsStableUnderTransfiniteComposition := sorry

class WeaklySaturated (P : MorphismProperty C) : Prop where
  IsStableUnderCobaseChange : P.IsStableUnderCobaseChange
  IsStableUnderRetracts : P.IsStableUnderRetracts
  IsStableUnderTransfiniteComposition : IsStableUnderTransfiniteComposition P

instance llp.WeaklySaturated (T : MorphismProperty C) : WeaklySaturated T.llp :=
  âŸ¨T.llp_isStableUnderCobaseChange, T.llp_isStableUnderRetracts, llp.IsStableUnderTransfiniteCompositionâŸ©

/-- weakly saturated classes contain all isomorphisms. -/
lemma WeaklySaturated_contains_iso (T : MorphismProperty C) [hT: WeaklySaturated T] (p : X âŸ¶ Y) :
    (isomorphisms C) p â†’ T p := fun hp â†¦
  letI : IsIso p := hp
  hT.IsStableUnderCobaseChange.of_isPushout (IsPushout.of_vert_isIso âŸ¨rflâŸ©) (hT.IsStableUnderTransfiniteComposition.id_mem X)

-- inductive type defining the weakly saturated class generated by a morphism property
inductive WeaklySaturatedOf (T : MorphismProperty C) : {X Y : C} â†’ (X âŸ¶ Y) â†’ Prop
  | of â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y) (h : T f) : WeaklySaturatedOf T f
  | pushout â¦ƒX Y Z W : Câ¦„ â¦ƒf : X âŸ¶ Yâ¦„ â¦ƒg : X âŸ¶ Zâ¦„ â¦ƒinl : Z âŸ¶ Wâ¦„ â¦ƒinr : Y âŸ¶ Wâ¦„ (_ : IsPushout g f inl inr) : WeaklySaturatedOf T f â†’ WeaklySaturatedOf T inl
  | retract â¦ƒX Y Z W : Câ¦„ â¦ƒf : X âŸ¶ Yâ¦„ â¦ƒg : Z âŸ¶ Wâ¦„ (_ : RetractArrow f g) : WeaklySaturatedOf T g â†’ WeaklySaturatedOf T f
  | id_mem (X : C) : WeaklySaturatedOf T (ðŸ™ X)
  | comp_mem {X Y Z} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : WeaklySaturatedOf T f â†’ WeaklySaturatedOf T g â†’ WeaklySaturatedOf T (f â‰« g)
  | transfinite (J : Type w) [LinearOrder J] [SuccOrder J] [OrderBot J] [WellFoundedLT J]
      (F : J â¥¤ C) [hf : F.IsWellOrderContinuous] (c : Limits.Cocone F) (hc : Limits.IsColimit c) :
      (âˆ€ (j : J), Â¬IsMax j â†’ T.WeaklySaturatedOf (F.map (homOfLE (Order.le_succ j)))) â†’ T.WeaklySaturatedOf (c.Î¹.app âŠ¥)

/-- the weakly saturated class generated by a morphism property. -/
def WeaklySaturatedClassOf (T : MorphismProperty C) : MorphismProperty C := fun _ _ f â†¦ WeaklySaturatedOf.{w} T f

-- do galois connection, galois insertion

instance of_is (T : MorphismProperty C) : WeaklySaturated.{v, u, w} (WeaklySaturatedClassOf.{w} T) where
  IsStableUnderCobaseChange := âŸ¨fun h hf â†¦ .pushout h hfâŸ©
  IsStableUnderRetracts := âŸ¨fun h hf â†¦ .retract h hfâŸ©
  IsStableUnderTransfiniteComposition := {
    id_mem := .id_mem
    comp_mem := .comp_mem
    isStableUnderTransfiniteCompositionOfShape := fun J _ _ _ _ â†¦ by
      refine âŸ¨fun _ _ f hf â†¦ ?_âŸ©
      induction hf with
      | mk F hF c hc => exact .transfinite J F c hc hF }

lemma le_WeaklySaturatedClassOf (T : MorphismProperty C) : T â‰¤ WeaklySaturatedClassOf T := .of

/-- if S is any other wsc containing T, then it contains the class generated by T. -/
lemma minimalWeaklySaturated (S T : MorphismProperty C) (h : T â‰¤ S) : WeaklySaturated.{_, _, w} S â†’ (WeaklySaturatedClassOf.{w} T) â‰¤ S := by
  intro hS X Y f hf
  induction hf with
  | of f hf => exact h _ hf
  | pushout h _ hf => exact hS.IsStableUnderCobaseChange.of_isPushout h hf
  | retract h _ hf => exact hS.IsStableUnderRetracts.of_retract h hf
  | id_mem => exact hS.IsStableUnderTransfiniteComposition.id_mem _
  | comp_mem f g _ _ hf hg => exact hS.IsStableUnderTransfiniteComposition.comp_mem f g hf hg
  | transfinite J F c hc _ hF => exact
    (hS.IsStableUnderTransfiniteComposition.isStableUnderTransfiniteCompositionOfShape J).le _ (.mk F hF c hc)

end MorphismProperty

end CategoryTheory
