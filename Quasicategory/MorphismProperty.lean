import Mathlib.CategoryTheory.MorphismProperty.TransfiniteComposition
import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting
import Mathlib.CategoryTheory.MorphismProperty.LiftingProperty

/-!

Defines `WeaklySaturated`.

need to update with the new API in mathlib

-/

universe w v u

namespace CategoryTheory

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

inductive Morphism {A B : C} (p : A ⟶ B) : {X Y : C} → (X ⟶ Y) → Prop
  | mk : (Morphism p) p

/-- the class of a single morphism `p`. -/
def MorphismClass {X Y : C} (p : X ⟶ Y) : MorphismProperty C := fun _ _ i ↦ (Morphism p) i

/-- a morphism `p` has rlp wrt a class `T` of morphisms iff every morphism in `T` has llp wrt `p`. -/
lemma class_rlp_iff_llp_morphism (T : MorphismProperty C) {X Y : C} (p : X ⟶ Y) : T.rlp p ↔
    ∀ {A B} (i : A ⟶ B) (_ : T i), (MorphismClass p).llp i := by
  refine ⟨fun hp _ _ _ hi _ _ _ h ↦ by induction h; exact hp _ hi, fun h _ _ i hi ↦ h i hi _ .mk⟩

/-- a morphism `p` has llp wrt a class `T` of morphisms iff every morphism in `T` has rlp wrt `p`. -/
lemma class_llp_iff_rlp_morphism (T : MorphismProperty C) {X Y : C} (p : X ⟶ Y) : T.llp p ↔
    ∀ {A B} (i : A ⟶ B) (_ : T i), (MorphismClass p).rlp i := by
  refine ⟨fun hp _ _ _ hi _ _ _ h ↦ by induction h; exact hp _ hi, fun h _ _ i hi ↦ h i hi _ .mk⟩

instance llp.IsStableUnderTransfiniteComposition {T : MorphismProperty C} :
    T.llp.IsStableUnderTransfiniteComposition := sorry

class WeaklySaturated (P : MorphismProperty C) : Prop where
  IsStableUnderCobaseChange : P.IsStableUnderCobaseChange
  IsStableUnderRetracts : P.IsStableUnderRetracts
  IsStableUnderTransfiniteComposition : IsStableUnderTransfiniteComposition P

instance llp.WeaklySaturated (T : MorphismProperty C) : WeaklySaturated T.llp :=
  ⟨T.llp_isStableUnderCobaseChange, T.llp_isStableUnderRetracts, llp.IsStableUnderTransfiniteComposition⟩

/-- weakly saturated classes contain all isomorphisms. -/
lemma WeaklySaturated_contains_iso (T : MorphismProperty C) [hT: WeaklySaturated T] (p : X ⟶ Y) :
    (isomorphisms C) p → T p := fun hp ↦
  letI : IsIso p := hp
  hT.IsStableUnderCobaseChange.of_isPushout (IsPushout.of_vert_isIso ⟨rfl⟩) (hT.IsStableUnderTransfiniteComposition.id_mem X)

-- inductive type defining the weakly saturated class generated by a morphism property
inductive WeaklySaturatedOf (T : MorphismProperty C) : {X Y : C} → (X ⟶ Y) → Prop
  | of ⦃X Y : C⦄ (f : X ⟶ Y) (h : T f) : WeaklySaturatedOf T f
  | pushout ⦃X Y Z W : C⦄ ⦃f : X ⟶ Y⦄ ⦃g : X ⟶ Z⦄ ⦃inl : Z ⟶ W⦄ ⦃inr : Y ⟶ W⦄ (_ : IsPushout g f inl inr) : WeaklySaturatedOf T f → WeaklySaturatedOf T inl
  | retract ⦃X Y Z W : C⦄ ⦃f : X ⟶ Y⦄ ⦃g : Z ⟶ W⦄ (_ : RetractArrow f g) : WeaklySaturatedOf T g → WeaklySaturatedOf T f
  | id_mem (X : C) : WeaklySaturatedOf T (𝟙 X)
  | comp_mem {X Y Z} (f : X ⟶ Y) (g : Y ⟶ Z) : WeaklySaturatedOf T f → WeaklySaturatedOf T g → WeaklySaturatedOf T (f ≫ g)
  | transfinite (J : Type w) [LinearOrder J] [SuccOrder J] [OrderBot J] [WellFoundedLT J]
      (F : J ⥤ C) [hf : F.IsWellOrderContinuous] (c : Limits.Cocone F) (hc : Limits.IsColimit c) :
      (∀ (j : J), ¬IsMax j → T.WeaklySaturatedOf (F.map (homOfLE (Order.le_succ j)))) → T.WeaklySaturatedOf (c.ι.app ⊥)

/-- the weakly saturated class generated by a morphism property. -/
def WeaklySaturatedClassOf (T : MorphismProperty C) : MorphismProperty C := fun _ _ f ↦ WeaklySaturatedOf.{w} T f

-- do galois connection, galois insertion

instance of_is (T : MorphismProperty C) : WeaklySaturated.{v, u, w} (WeaklySaturatedClassOf.{w} T) where
  IsStableUnderCobaseChange := ⟨fun h hf ↦ .pushout h hf⟩
  IsStableUnderRetracts := ⟨fun h hf ↦ .retract h hf⟩
  IsStableUnderTransfiniteComposition := {
    id_mem := .id_mem
    comp_mem := .comp_mem
    isStableUnderTransfiniteCompositionOfShape := fun J _ _ _ _ ↦ by
      refine ⟨fun _ _ f hf ↦ ?_⟩
      induction hf with
      | mk F hF c hc => exact .transfinite J F c hc hF }

lemma le_WeaklySaturatedClassOf (T : MorphismProperty C) : T ≤ WeaklySaturatedClassOf T := .of

/-- if S is any other wsc containing T, then it contains the class generated by T. -/
lemma minimalWeaklySaturated (S T : MorphismProperty C) (h : T ≤ S) : WeaklySaturated.{_, _, w} S → (WeaklySaturatedClassOf.{w} T) ≤ S := by
  intro hS X Y f hf
  induction hf with
  | of f hf => exact h _ hf
  | pushout h _ hf => exact hS.IsStableUnderCobaseChange.of_isPushout h hf
  | retract h _ hf => exact hS.IsStableUnderRetracts.of_retract h hf
  | id_mem => exact hS.IsStableUnderTransfiniteComposition.id_mem _
  | comp_mem f g _ _ hf hg => exact hS.IsStableUnderTransfiniteComposition.comp_mem f g hf hg
  | transfinite J F c hc _ hF => exact
    (hS.IsStableUnderTransfiniteComposition.isStableUnderTransfiniteCompositionOfShape J).le _ (.mk F hF c hc)

end MorphismProperty

end CategoryTheory
