import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting
import Mathlib.SetTheory.Cardinal.Order
import Mathlib.CategoryTheory.SmallObject.Basic

universe w v u

namespace CategoryTheory

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

variable (T : MorphismProperty C)

inductive Morphism {X Y : C} (p : X âŸ¶ Y) : {A B : C} â†’ (A âŸ¶ B) â†’ Prop
  | mk : (Morphism p) p

section Morphism

variable {X Y : C} (p : X âŸ¶ Y)

/-- the class of a single morphism `p`. -/
def morphism : MorphismProperty C := fun _ _ i â†¦ (Morphism p) i

/-- a morphism `p` has rlp wrt a class `T` of morphisms iff every morphism in `T` has llp wrt `p`. -/
lemma morphism_rlp_iff : T.rlp p â†” T â‰¤ (morphism p).llp :=
  âŸ¨fun hp _ _ _ hi _ _ _ âŸ¨âŸ© â†¦ hp _ hi, fun h _ _ i hi â†¦ h i hi _ .mkâŸ©

lemma morphism_llp_iff : T.llp p â†” T â‰¤ (morphism p).rlp :=
  âŸ¨fun hp _ _ _ hi _ _ _ âŸ¨âŸ© â†¦ hp _ hi, fun h _ _ i hi â†¦ h i hi _ .mkâŸ©

lemma morphism_le_iff : morphism p â‰¤ T â†” T p :=
  âŸ¨fun h â†¦ h _ .mk, fun h _ _ _ âŸ¨âŸ© â†¦ hâŸ©

end Morphism

section LiftingProperty

open Limits

variable {X Y : C} {p : X âŸ¶ Y}

variable [HasInitial C] [InitialMonoClass C]

@[simp]
noncomputable
def _root_.CategoryTheory.HasLiftingProperty.section_of_initial_to_left
    (h : HasLiftingProperty (initial.to Y) p) : Y âŸ¶ X :=
  (h.sq_hasLift (CommSq.mk (initial.hom_ext (initial.to X â‰« p) (initial.to Y â‰« ğŸ™ Y)))).exists_lift.some.l

noncomputable
instance splitEpi_of_monomorphisms_rlp
    (hp : (monomorphisms C).rlp p) : SplitEpi p where
  section_ := (hp _ (initial.mono_from _ _)).section_of_initial_to_left
  id := CategoryTheory.CommSq.LiftStruct.fac_right _

end LiftingProperty

section WeaklySaturated

class WeaklySaturated : Prop where
  IsStableUnderCobaseChange : T.IsStableUnderCobaseChange
  IsStableUnderRetracts : T.IsStableUnderRetracts
  IsStableUnderCoproducts : IsStableUnderCoproducts.{w} T
  IsStableUnderTransfiniteComposition : IsStableUnderTransfiniteComposition.{w} T

instance [h : WeaklySaturated T] : T.IsStableUnderCobaseChange :=
  h.IsStableUnderCobaseChange

instance [h : WeaklySaturated T] : T.IsStableUnderRetracts :=
  h.IsStableUnderRetracts

instance [h : WeaklySaturated.{w} T] : IsStableUnderTransfiniteComposition.{w} T :=
  h.IsStableUnderTransfiniteComposition

instance [h : WeaklySaturated.{w} T] : IsStableUnderCoproducts.{w} T :=
  h.IsStableUnderCoproducts

instance llp_isWeaklySaturated : WeaklySaturated T.llp :=
  âŸ¨T.llp_isStableUnderCobaseChange, T.llp_isStableUnderRetracts, âŸ¨T.llp_isStableUnderCoproductsOfShapeâŸ©, âŸ¨T.isStableUnderTransfiniteCompositionOfShape_llpâŸ©âŸ©

/-- weakly saturated classes contain all isomorphisms. -/
lemma WeaklySaturated.isomorphisms_le [WeaklySaturated T] :
    isomorphisms C â‰¤ T := fun _ _ p hp â†¦
  letI : IsIso p := hp
  WeaklySaturated.IsStableUnderCobaseChange.of_isPushout (IsPushout.of_vert_isIso âŸ¨rflâŸ©) (ContainsIdentities.id_mem _)

open Limits in
/-- inductive type defining the weakly saturated class generated by a morphism property -/
inductive WeaklySaturatedClass (T : MorphismProperty C) : {X Y : C} â†’ (X âŸ¶ Y) â†’ Prop
  | of â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y) (h : T f) : WeaklySaturatedClass T f
  | pushout â¦ƒX Y Z W : Câ¦„ â¦ƒf : X âŸ¶ Yâ¦„ â¦ƒg : X âŸ¶ Zâ¦„ â¦ƒinl : Z âŸ¶ Wâ¦„ â¦ƒinr : Y âŸ¶ Wâ¦„ (_ : IsPushout g f inl inr) : WeaklySaturatedClass T f â†’ WeaklySaturatedClass T inl
  | retract â¦ƒX Y Z W : Câ¦„ â¦ƒf : X âŸ¶ Yâ¦„ â¦ƒg : Z âŸ¶ Wâ¦„ (_ : RetractArrow f g) : WeaklySaturatedClass T g â†’ WeaklySaturatedClass T f
  | coproduct (J : Type w) (Xâ‚ Xâ‚‚ : Discrete J â¥¤ C) (câ‚ : Cocone Xâ‚) (câ‚‚ : Cocone Xâ‚‚) (hâ‚ : IsColimit câ‚) (_ : IsColimit câ‚‚)
      (f : Xâ‚ âŸ¶ Xâ‚‚) : (_ : âˆ€ (j : Discrete J), (WeaklySaturatedClass T) (f.app j)) â†’ WeaklySaturatedClass T (hâ‚.desc (Cocone.mk _ (f â‰« câ‚‚.Î¹)))
  | transfinite (J : Type w) [LinearOrder J] [SuccOrder J] [OrderBot J] [WellFoundedLT J]
      {X Y : C} (f : X âŸ¶ Y) (hf : CategoryTheory.TransfiniteCompositionOfShape J f) :
        (âˆ€ (j : J), (hj : Â¬IsMax j) â†’ WeaklySaturatedClass T (hf.F.map (homOfLE (Order.le_succ j)))) â†’ WeaklySaturatedClass T f

/-- the weakly saturated class generated by a morphism property. -/
def saturation : MorphismProperty C := fun _ _ f â†¦ WeaklySaturatedClass.{w} T f

-- do galois connection, galois insertion

instance saturation_isWeaklySaturated (T : MorphismProperty C) : WeaklySaturated.{w} (saturation.{w} T) where
  IsStableUnderCobaseChange := âŸ¨fun h hf â†¦ .pushout h hfâŸ©
  IsStableUnderRetracts := âŸ¨fun h hf â†¦ .retract h hfâŸ©
  IsStableUnderCoproducts := âŸ¨fun J _ _ _ _ _ hâ‚‚ f hf â†¦
    .coproduct J _ _ _ _ _ hâ‚‚ f hfâŸ©
  IsStableUnderTransfiniteComposition := âŸ¨fun J _ _ _ _ â†¦
    âŸ¨fun _ _ f hf â†¦ .transfinite J f _ hf.some.map_memâŸ©âŸ©

lemma le_saturation : T â‰¤ T.saturation := .of

lemma WeaklySaturated.le_iff (S : MorphismProperty C) [WeaklySaturated.{w} S] : T â‰¤ S â†” (saturation.{w} T) â‰¤ S := by
  constructor
  Â· intro h _ _ f hf
    induction hf with
    | of f hf => exact h _ hf
    | pushout h _ hf => exact WeaklySaturated.IsStableUnderCobaseChange.of_isPushout h hf
    | retract h _ hf => exact WeaklySaturated.IsStableUnderRetracts.of_retract h hf
    | coproduct J Xâ‚ Xâ‚‚ câ‚ câ‚‚ hâ‚ hâ‚‚ f hf hs =>
      exact (WeaklySaturated.IsStableUnderCoproducts.isStableUnderCoproductsOfShape J).colimitsOfShape_le _ âŸ¨Xâ‚, Xâ‚‚, câ‚, câ‚‚, hâ‚, hâ‚‚, f, hsâŸ©
    | transfinite J f hF h' h'' =>
      exact (WeaklySaturated.IsStableUnderTransfiniteComposition.isStableUnderTransfiniteCompositionOfShape J).le _ âŸ¨hF, h''âŸ©
  Â· exact T.le_saturation.trans

lemma llp_rlp_eq_saturation {T : MorphismProperty C} [HasSmallObjectArgument.{w} T] :
    T.rlp.llp = saturation.{w} T := by
  apply le_antisymm
  Â· rw [llp_rlp_of_hasSmallObjectArgument, retracts_le_iff,
      transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact le_saturation _
  Â· rw [â† WeaklySaturated.le_iff]
    exact T.le_llp_rlp

lemma saturation_saturation_eq {T : MorphismProperty C} :
    saturation.{w} (saturation.{w} T) = saturation.{w} T := by
  apply le_antisymm
  Â· rw [â† WeaklySaturated.le_iff]
  Â· exact le_saturation _

end WeaklySaturated

end MorphismProperty

end CategoryTheory
