import Mathlib.AlgebraicTopology.RelativeCellComplex.Basic
import Mathlib.CategoryTheory.Limits.Lattice
import Quasicategory.TopCatModelCategory.SSet.Degenerate
import Quasicategory.TopCatModelCategory.SSet.Evaluation
import Quasicategory.TopCatModelCategory.SSet.Monomorphisms
import Quasicategory.TopCatModelCategory.ColimitsType

open CategoryTheory Simplicial HomotopicalAlgebra Limits Opposite

namespace SSet

lemma mono_of_nonDegenerate {X : SSet.{u}} {d d' : ‚Ñï} (x : X _‚¶ãd‚¶å)
    (f : ‚¶ãd'‚¶å ‚ü∂ ‚¶ãd‚¶å)
    (h : X.map f.op x ‚àà X.nonDegenerate d') : Mono f := by
  have := isIso_of_nonDegenerate _ ‚ü®_, h‚ü© (factorThruImage f)
    (X.map (image.Œπ f).op x) (by
      rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, image.fac])
  rw [‚Üê image.fac f]
  infer_instance

variable (X : SSet.{u})

/-- `X.skeleton n` is the subcomplex of `X` generated by (non degenerate)
simplices of dimension `< n`. -/
def skeleton : ‚Ñï ‚Üío X.Subcomplex where
  toFun n := ‚®Ü (i : Fin n) (x : X.nonDegenerate i), Subcomplex.ofSimplex x.1
  monotone' i j h := by
    simp only [iSup_le_iff]
    intro k x
    exact le_trans (by exact le_trans (by rfl) (le_iSup _ x))
      (le_iSup _ ‚ü®k, by omega‚ü©)

lemma mem_skeleton {i : ‚Ñï} (x : X _‚¶ãi‚¶å) {n : ‚Ñï} (hi : i < n) :
    x ‚àà (X.skeleton n).obj _ := by
  obtain ‚ü®j, f, _, y, rfl‚ü© := X.exists_nonDegenerate x
  suffices Subcomplex.ofSimplex y.1 ‚â§ X.skeleton n from
    (X.skeleton n).map _ (this _ (Subcomplex.mem_ofSimplex_obj _))
  exact le_trans (by exact le_trans (by rfl) (le_iSup _ y))
    (le_iSup _ ‚ü®j, lt_of_le_of_lt
      (SimplexCategory.len_le_of_epi (f := f) inferInstance) hi‚ü©)

lemma skeleton_obj_eq_top {d n : ‚Ñï} (h : d < n) :
    (X.skeleton n).obj (op ‚¶ãd‚¶å) = ‚ä§ := by
  rw [‚Üê top_le_iff]
  intro x _
  exact mem_skeleton _ _ h

lemma ofSimplex_le_skeleton {i : ‚Ñï} (x : X _‚¶ãi‚¶å) {n : ‚Ñï} (hi : i < n) :
    Subcomplex.ofSimplex x ‚â§ X.skeleton n := by
  simpa using X.mem_skeleton x hi

lemma mem_skeleton_obj_iff_of_nonDegenerate
    {d : ‚Ñï} (x : X.nonDegenerate d) (n : ‚Ñï) :
    x.1 ‚àà (X.skeleton n).obj _ ‚Üî d < n := by
  constructor
  ¬∑ intro h
    simp [skeleton] at h
    obtain ‚ü®x, hx‚ü© := x
    obtain ‚ü®‚ü®i, hi‚ü©, y, hy, ‚ü®f‚ü©, rfl‚ü© := h
    dsimp at y hy f
    have : d ‚â§ i := SimplexCategory.len_le_of_mono
      (mono_of_nonDegenerate y f hx)
    omega
  ¬∑ apply mem_skeleton

@[simp]
lemma skeleton_zero : X.skeleton 0 = ‚ä• := by
  simp [skeleton]

lemma iSup_skeleton : ‚®Ü (n : ‚Ñï), X.skeleton n = ‚ä§ := by
  apply le_antisymm (by simp)
  rw [Subcomplex.le_iff_contains_nonDegenerate]
  intro n x _
  simp only [Subpresheaf.iSup_obj, Set.mem_iUnion]
  exact ‚ü®n + 1, mem_skeleton _ _ (by omega)‚ü©

lemma skeleton_succ (n : ‚Ñï) :
    X.skeleton (n + 1) =
      X.skeleton n ‚äî ‚®Ü (x : X.nonDegenerate n), Subcomplex.ofSimplex x.1 := by
  apply le_antisymm
  ¬∑ conv_lhs => dsimp [skeleton]
    simp only [iSup_le_iff]
    rintro ‚ü®d, hd‚ü© x
    rw [Nat.lt_succ_iff] at hd
    obtain hd | rfl := hd.lt_or_eq
    ¬∑ exact (X.ofSimplex_le_skeleton _ hd).trans le_sup_left
    ¬∑ exact le_trans (le_trans (by rfl) (le_iSup _ x)) le_sup_right
  ¬∑ simp only [sup_le_iff, iSup_le_iff]
    constructor
    ¬∑ exact X.skeleton.monotone (by simp)
    ¬∑ intro x
      apply X.ofSimplex_le_skeleton _ (by simp)

variable {X} {Y : SSet.{u}} (i : X ‚ü∂ Y)

def skeletonOfMono [Mono i] : ‚Ñï ‚Üío Y.Subcomplex where
  toFun n := Subcomplex.range i ‚äî Y.skeleton n
  monotone' n m h := by
    dsimp
    simp only [sup_le_iff, le_sup_left, true_and]
    exact le_trans (Y.skeleton.monotone h) le_sup_right

section

variable [Mono i]

lemma skeleton_le_skeletonOfMono (n : ‚Ñï) :
    Y.skeleton n ‚â§ skeletonOfMono i n := le_sup_right

@[simp]
lemma skeletonOfMono_zero : skeletonOfMono i 0 = Subcomplex.range i := by
  simp [skeletonOfMono]

lemma iSup_skeletonOfMono : ‚®Ü (n : ‚Ñï), skeletonOfMono i n = ‚ä§ := by
  apply le_antisymm (by simp)
  rw [‚Üê Y.iSup_skeleton, iSup_le_iff]
  intro n
  exact le_trans (skeleton_le_skeletonOfMono i n) (le_iSup _ n)

lemma mem_skeletonOfMono_obj_iff_of_nonDegenerate
    {d : ‚Ñï} (x : Y.nonDegenerate d) (n : ‚Ñï) :
    x.1 ‚àà (skeletonOfMono i n).obj _ ‚Üî
      x.1 ‚àà Set.range (i.app _) ‚à® d < n := by
  simp [skeletonOfMono, mem_skeleton_obj_iff_of_nonDegenerate]

lemma skeletonOfMono_obj_eq_top {d n : ‚Ñï} (h : d < n) :
    (skeletonOfMono i n).obj (op ‚¶ãd‚¶å) = ‚ä§ := by
  rw [‚Üê top_le_iff, ‚Üê Y.skeleton_obj_eq_top h]
  exact le_sup_right

lemma skeletonOfMono_succ (n : ‚Ñï) :
    skeletonOfMono i (n + 1) =
      skeletonOfMono i n ‚äî ‚®Ü (x : Y.nonDegenerate n)
        (_ : x.1 ‚àâ (Subcomplex.range i).obj _), Subcomplex.ofSimplex x.1 := by
  dsimp only [skeletonOfMono, OrderHom.coe_mk]
  apply le_antisymm
  ¬∑ simp only [sup_le_iff, iSup_le_iff, skeleton_succ]
    refine ‚ü®le_sup_left.trans le_sup_left,
      le_sup_right.trans le_sup_left, fun x ‚Ü¶ ?_‚ü©
    by_cases hx : x.1 ‚àà (Subcomplex.range i).obj _
    ¬∑ exact le_trans (le_trans (by simpa) le_sup_left) le_sup_left
    ¬∑ exact (le_trans (by exact le_trans (by rfl) (le_iSup _ hx))
        (le_iSup _ x)).trans le_sup_right
  ¬∑ simp only [sup_le_iff, iSup_le_iff]
    exact ‚ü®‚ü®le_sup_left, (Y.skeleton.monotone (by simp)).trans le_sup_right‚ü©,
      fun _ _ ‚Ü¶ (Y.ofSimplex_le_skeleton _ (by simp)).trans le_sup_right‚ü©

end

namespace relativeCellComplexOfMono

variable (d : ‚Ñï)

def Œπ [Mono i] : Type u :=
  { y : Y.nonDegenerate d // y.1 ‚àâ (Subcomplex.range i).obj _ }

variable [Mono i]

noncomputable def A : SSet.{u} := ‚àê (fun (_ : Œπ i d) ‚Ü¶ boundary d)

noncomputable def B : SSet.{u} := ‚àê (fun (_ : Œπ i d) ‚Ü¶ Œî[d])

variable {i d}

noncomputable def ŒπA (x : Œπ i d) : (boundary d : SSet) ‚ü∂ A i d :=
  Limits.Sigma.Œπ (fun _ ‚Ü¶ _) x

noncomputable def ŒπB (x : Œπ i d) : Œî[d] ‚ü∂ B i d :=
  Limits.Sigma.Œπ (fun _ ‚Ü¶ _) x

lemma ŒπA_jointly_surjective {n : ‚Ñï} (a : (A i d) _‚¶ãn‚¶å) :
    ‚àÉ (x : Œπ i d) (a' : (‚àÇŒî[d] : SSet) _‚¶ãn‚¶å), (ŒπA x).app _ a' = a :=
  Types.jointly_surjective_of_isColimit_cofan
    (isColimitCofanMkObjOfIsColimit ((evaluation _ _).obj (op ‚¶ãn‚¶å)) _ _
    (coproductIsCoproduct _)) a

lemma ŒπB_jointly_surjective {n : ‚Ñï} (b : (B i d) _‚¶ãn‚¶å) :
    ‚àÉ (x : Œπ i d) (b' : Œî[d] _‚¶ãn‚¶å), (ŒπB x).app _ b' = b :=
  Types.jointly_surjective_of_isColimit_cofan
    (isColimitCofanMkObjOfIsColimit ((evaluation _ _).obj (op ‚¶ãn‚¶å)) _ _
    (coproductIsCoproduct _)) b

variable (i d) in
noncomputable def m : A i d ‚ü∂ B i d := Limits.Sigma.map (fun _ ‚Ü¶ (boundary d).Œπ)

instance : Mono (m i d) := by
  dsimp [m]
  infer_instance

@[reassoc (attr := simp)]
lemma ŒπA_m (x : Œπ i d) : ŒπA x ‚â´ m i d = (boundary d).Œπ ‚â´ ŒπB x := by
  simp [m, ŒπA, ŒπB]

lemma mem_skeletonOfMono (x : Œπ i d) {d' : ‚Ñï} (h : d < d') :
    x.1.1 ‚àà (skeletonOfMono i d').obj _ := by
  simp only [skeletonOfMono, OrderHom.coe_mk, Subpresheaf.max_obj, Set.mem_union]
  exact Or.inr (Y.mem_skeleton _ h)

def Œ≤ (x : Œπ i d) : Œî[d] ‚ü∂ skeletonOfMono i (d + 1) :=
  yonedaEquiv.symm ‚ü®x.1.1, mem_skeletonOfMono x (by simp)‚ü©

variable (i d) in
noncomputable def b : B i d ‚ü∂ skeletonOfMono i (d + 1) := Sigma.desc Œ≤

@[reassoc (attr := simp)]
lemma ŒπB_b (x : Œπ i d) : ŒπB x ‚â´ b i d = Œ≤ x := by simp [ŒπB, b]

lemma preimage_skeletonOfMono_eq (x : Œπ i d) :
    (skeletonOfMono i d).preimage (yonedaEquiv.symm x.1.1) = ‚àÇŒî[d] := by
  rw [stdSimplex.eq_boundary_iff]
  constructor
  ¬∑ rw [Subcomplex.le_iff_contains_nonDegenerate]
    rintro n ‚ü®y, hy‚ÇÅ‚ü© hy‚ÇÇ
    have : n < d := dim_lt_of_nondegenerate (X := ‚àÇŒî[d])
      (‚ü®‚ü®y, hy‚ÇÇ‚ü©, by rwa [Subcomplex.mem_nonDegenerate_iff]‚ü©) d
    simp [skeletonOfMono_obj_eq_top i this]
  ¬∑ intro h
    have := h.symm.le _ (show stdSimplex.objEquiv.symm (ùüô ‚¶ãd‚¶å)  ‚àà _ by simp)
    simp only [Subpresheaf.range_obj, Subcomplex.preimage_obj, Set.mem_preimage] at this
    change Y.map (ùüô _) x.1.1 ‚àà (skeletonOfMono i d).obj _ at this
    simp only [Subpresheaf.range_obj, FunctorToTypes.map_id_apply,
      mem_skeletonOfMono_obj_iff_of_nonDegenerate, Set.mem_range, lt_self_iff_false,
      or_false] at this
    exact x.2 this

def œÑ (x : Œπ i d) : (‚àÇŒî[d] : SSet) ‚ü∂ skeletonOfMono i d :=
  Subcomplex.lift (‚àÇŒî[d].Œπ ‚â´ yonedaEquiv.symm x.1.1) (by
    rw [Subcomplex.preimage_preimage, preimage_skeletonOfMono_eq,
      Subcomplex.preimage_Œπ])

@[simp]
lemma œÑ_app_coe (x : Œπ i d) {n : ‚Ñï} (a : (‚àÇŒî[d] : SSet) _‚¶ãn‚¶å) :
    ((œÑ x).app _ a).1 = (Œ≤ x).app _ a.1 := rfl

variable (i d) in
noncomputable def t : A i d ‚ü∂ skeletonOfMono i d := Sigma.desc œÑ

@[reassoc (attr := simp)]
lemma ŒπA_t (x : Œπ i d) : ŒπA x ‚â´ t i d = œÑ x := by simp [ŒπA, t]

variable (i d) in
def r : (skeletonOfMono i d : SSet) ‚ü∂ skeletonOfMono i (d + 1) :=
  Subcomplex.homOfLE ((skeletonOfMono i).monotone (by simp))

variable (i d) in
instance mono_r : Mono (r i d) := by dsimp [r]; infer_instance

@[reassoc]
lemma œÑ_r (x : Œπ i d) : œÑ x ‚â´ r i d = ‚àÇŒî[d].Œπ ‚â´ Œ≤ x := rfl

@[simp]
lemma r_app_coe {n : ‚Ñï} (y : (skeletonOfMono i d : SSet) _‚¶ãn‚¶å) :
    ((r i d).app _ y).1 = y.1 := rfl

variable (i d)

@[reassoc]
lemma w : t i d ‚â´ r i d = m i d ‚â´ b i d :=
  Sigma.hom_ext _ _ (fun x ‚Ü¶ by
    change ŒπA x ‚â´ t i d ‚â´ r i d = ŒπA x ‚â´ m i d ‚â´ b i d
    simp [œÑ_r])

lemma sup_range_r_range_b :
    Subcomplex.range (r i d) ‚äî Subcomplex.range (b i d) = ‚ä§ := by
  rw [‚Üê top_le_iff]
  rintro n ‚ü®x, hx‚ü© _
  simp only [skeletonOfMono_succ, Subpresheaf.range_obj, Set.mem_range, not_exists,
    Subpresheaf.max_obj, Subpresheaf.iSup_obj, Subcomplex.iSup_obj, Set.iUnion_coe_set,
    Set.mem_union, Set.mem_iUnion, exists_prop, exists_and_left] at hx
  simp only [Subpresheaf.toPresheaf_obj, Subpresheaf.max_obj, Subpresheaf.range_obj, Set.mem_union,
    Set.mem_range, Subtype.exists]
  obtain hx | ‚ü®y, hy‚ÇÅ, hy‚ÇÇ, ‚ü®f‚ü©, rfl‚ü©  := hx
  ¬∑ exact Or.inl ‚ü®x, hx, rfl‚ü©
  ¬∑ refine Or.inr ‚ü®(ŒπB ‚ü®‚ü®y, hy‚ÇÅ‚ü©, by simpa‚ü©).app _
      (stdSimplex.objEquiv.symm f), ?_‚ü©
    rw [‚Üê FunctorToTypes.comp, ŒπB_b]
    rfl

lemma range_r_app_union_range_b_app (n : SimplexCategory·µí·µñ) :
    Set.range ((r i d).app n) ‚à™
      Set.range ((b i d).app n) = Set.univ :=
  congr_fun (congr_arg Subpresheaf.obj (sup_range_r_range_b i d)) n

lemma isPullback : IsPullback (t i d) (m i d) (r i d) (b i d) where
  w := w i d
  isLimit' := ‚ü®evaluationJointlyReflectsLimits _ (fun ‚ü®n‚ü© ‚Ü¶ by
    refine (isLimitMapConePullbackConeEquiv _ _).2
      (IsPullback.isLimit ?_)
    induction' n using SimplexCategory.rec with n
    rw [Types.isPullback_iff]
    dsimp
    refine ‚ü®?_, ?_, ?_‚ü©
    ¬∑ exact (congr_app (w i d) (op ‚¶ãn‚¶å))
    ¬∑ intro a‚ÇÅ a‚ÇÇ ‚ü®ht, hm‚ü©
      have : Mono (m i d) := inferInstance
      rw [NatTrans.mono_iff_mono_app] at this
      simp only [mono_iff_injective] at this
      exact this _ hm
    ¬∑ intro y b h
      obtain ‚ü®x, b, rfl‚ü© := ŒπB_jointly_surjective b
      have hb : b ‚àà ‚àÇŒî[d].obj _ := by
        obtain ‚ü®y, hy‚ü© := y
        rw [‚Üê preimage_skeletonOfMono_eq x]
        rw [Subtype.ext_iff] at h
        dsimp at h
        subst h
        rwa [‚Üê FunctorToTypes.comp, ŒπB_b] at hy
      refine ‚ü®(ŒπA x).app _ ‚ü®b, hb‚ü©, ?_, ?_‚ü©
      ¬∑ rw [Subtype.ext_iff] at h
        dsimp at h
        rw [‚Üê FunctorToTypes.comp, ŒπA_t]
        rw [‚Üê FunctorToTypes.comp, ŒπB_b] at h
        ext
        exact h
      ¬∑ rw [‚Üê FunctorToTypes.comp, ŒπA_m, comp_app, types_comp_apply,
          Subpresheaf.Œπ_app])‚ü©


variable {i d} in
lemma exists_epi {n : ‚Ñï} (y : (B i d) _‚¶ãn‚¶å)
    (hy : y ‚àâ Set.range ((m i d).app (op ‚¶ãn‚¶å))) :
    ‚àÉ (x : Œπ i d) (f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãd‚¶å) (_ : Epi f),
    (ŒπB x).app (op ‚¶ãn‚¶å) (stdSimplex.objEquiv.symm f) = y := by
  obtain ‚ü®x, s, rfl‚ü© := ŒπB_jointly_surjective y
  have hs : s ‚àâ ‚àÇŒî[d].obj _ := fun hs ‚Ü¶ hy (‚ü®(ŒπA x).app _ ‚ü®s, hs‚ü©, by
    rw [‚Üê FunctorToTypes.comp, ŒπA_m, comp_app, types_comp_apply, Subpresheaf.Œπ_app]‚ü©)
  refine ‚ü®x, stdSimplex.objEquiv (m := op ‚¶ãn‚¶å) s,
    by simpa [SimplexCategory.epi_iff_surjective, boundary] using hs,
    by simp‚ü©

lemma isPushout : IsPushout (t i d) (m i d) (r i d) (b i d) where
  w := w i d
  isColimit' := ‚ü®evaluationJointlyReflectsColimits _ (fun ‚ü®n‚ü© ‚Ü¶ by
    induction' n using SimplexCategory.rec with n
    refine (isColimitMapCoconePushoutCoconeEquiv _ _).2
      (IsPushout.isColimit ?_)
    have := mono_r i d
    refine Limits.Types.isPushout_of_isPullback_of_mono' ?_ ?_ ?_
    ¬∑ exact (isPullback i d).map ((evaluation _ _).obj (op ‚¶ãn‚¶å))
    ¬∑ exact range_r_app_union_range_b_app _ _ _
    ¬∑ dsimp
      intro y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ h
      obtain ‚ü®x‚ÇÅ, f‚ÇÅ, _, rfl‚ü© := exists_epi y‚ÇÅ hy‚ÇÅ
      obtain ‚ü®x‚ÇÇ, f‚ÇÇ, _, rfl‚ü© := exists_epi y‚ÇÇ hy‚ÇÇ
      have h' : Y.map f‚ÇÅ.op x‚ÇÅ.1.1 = Y.map f‚ÇÇ.op x‚ÇÇ.1.1 := by
        rwa [‚Üê FunctorToTypes.comp, ‚Üê FunctorToTypes.comp, ŒπB_b, ŒπB_b,
          Subtype.ext_iff] at h
      obtain rfl : x‚ÇÅ = x‚ÇÇ := by
        rw [Subtype.ext_iff]
        exact Y.unique_nonDegenerate‚ÇÇ _ f‚ÇÅ x‚ÇÅ.1 rfl f‚ÇÇ x‚ÇÇ.1 h'
      obtain rfl : f‚ÇÅ = f‚ÇÇ :=
        Y.unique_nonDegenerate‚ÇÉ _ f‚ÇÅ x‚ÇÅ.1 rfl f‚ÇÇ x‚ÇÅ.1 h'
      rfl)‚ü©

end relativeCellComplexOfMono

open relativeCellComplexOfMono in
noncomputable def relativeCellComplexOfMono [Mono i] :
    RelativeCellComplex.{u} (basicCell := fun (n : ‚Ñï) (_ : Unit) ‚Ü¶ (boundary n).Œπ) i where
  F := (skeletonOfMono i).monotone.functor ‚ãô Subcomplex.toPresheafFunctor
  isoBot := Subcomplex.isoOfEq (by simp) ‚â™‚â´ (asIso (toRangeSubcomplex i)).symm
  incl :=
    { app _ := Subcomplex.Œπ _
      naturality _ _ _ := rfl }
  isColimit := IsColimit.ofIsoColimit
      (isColimitOfPreserves Subcomplex.toPresheafFunctor
        ((CompleteLattice.colimitCocone
        ((skeletonOfMono i).monotone.functor)).isColimit))
          (Cocones.ext
            ((Subcomplex.isoOfEq (iSup_skeletonOfMono i)) ‚â™‚â´ Subcomplex.topIso Y)
        (fun _ ‚Ü¶ by rfl))
  attachCells d hd :=
    { Œπ := Œπ i d
      œÄ _ := ‚ü®‚ü©
      isColimit‚ÇÅ := colimit.isColimit _
      isColimit‚ÇÇ := colimit.isColimit _
      m := m i d
      hm := ŒπA_m
      g‚ÇÅ := t i d
      g‚ÇÇ := b i d
      isPushout := isPushout i d }

namespace modelCategoryQuillen

open MorphismProperty

noncomputable def transfiniteCompositionOfMono {X Y : SSet.{u}} (i : X ‚ü∂ Y) [Mono i] :
    (coproducts.{u} I).pushouts.TransfiniteCompositionOfShape ‚Ñï i where
  toTransfiniteCompositionOfShape :=
    (relativeCellComplexOfMono i).toTransfiniteCompositionOfShape
  map_mem d hd := by
    apply pushouts_monotone _ _
      ((relativeCellComplexOfMono i).attachCells d hd).pushouts_coproducts
    apply coproducts_monotone
    rintro _ _ _ ‚ü®‚ü©
    exact boundary_Œπ_mem_I d

lemma transfiniteCompositions_pushouts_coproducts :
    transfiniteCompositions.{u} (coproducts.{u} I).pushouts = monomorphisms SSet.{u} := by
  apply le_antisymm
  ¬∑ rw [transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact I_le_monomorphisms
  ¬∑ intro _ _ i (_ : Mono i)
    apply transfiniteCompositionsOfShape_le_transfiniteCompositions _ (ULift ‚Ñï)
    exact ‚ü®(transfiniteCompositionOfMono i).ofOrderIso (orderIsoULift.{u} ‚Ñï).symm‚ü©

lemma I_rlp_eq_monomorphisms_rlp : I.{u}.rlp = (monomorphisms SSet.{u}).rlp := by
  apply le_antisymm
  ¬∑ simp only [‚Üê transfiniteCompositions_pushouts_coproducts,
      rlp_transfiniteCompositions, rlp_pushouts, rlp_coproducts, le_refl]
  ¬∑ exact MorphismProperty.antitone_rlp I_le_monomorphisms

end modelCategoryQuillen

end SSet
